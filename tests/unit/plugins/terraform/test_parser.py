from __future__ import annotations

import json
from pathlib import Path
from typing import Any

import pytest

from src.plugins.terraform.parser import TerraformParser


class _FakeCompleted:
    def __init__(self, stdout: str, returncode: int = 0, stderr: str = ""):
        self.stdout = stdout
        self.returncode = returncode
        self.stderr = stderr


def _fake_which(path: str) -> str | None:
    return "/usr/bin/terraform"


class TestTerraformParserDiscovery:
    def test_can_parse_dir_with_tf(self, tmp_path: Path) -> None:
        p = TerraformParser()
        d = tmp_path / "proj"
        d.mkdir()
        (d / "main.tf").write_text("# tf")
        assert p.can_parse(d) is True

    def test_can_parse_requires_dir(self, tmp_path: Path) -> None:
        p = TerraformParser()
        f = tmp_path / "main.tf"
        f.write_text("# tf")
        assert p.can_parse(f) is False

    def test_can_parse_dir_without_tf(self, tmp_path: Path) -> None:
        p = TerraformParser()
        d = tmp_path / "proj"
        d.mkdir()
        (d / "readme.md").write_text("x")
        assert p.can_parse(d) is False


class TestValidateFile:
    def test_validate_ok(self, tmp_path: Path) -> None:
        p = TerraformParser()
        d = tmp_path / "proj"
        d.mkdir()
        (d / "m.tf").write_text("# tf")
        p.validate_file(d)  # should not raise

    def test_validate_missing(self, tmp_path: Path) -> None:
        p = TerraformParser()
        with pytest.raises(FileNotFoundError):
            p.validate_file(tmp_path / "missing")

    def test_validate_file_not_dir(self, tmp_path: Path) -> None:
        p = TerraformParser()
        f = tmp_path / "m.tf"
        f.write_text("# tf")
        with pytest.raises(ValueError, match="requires a directory"):
            p.validate_file(f)

    def test_validate_dir_without_tf(self, tmp_path: Path) -> None:
        p = TerraformParser()
        d = tmp_path / "proj"
        d.mkdir()
        with pytest.raises(ValueError, match="does not contain Terraform files"):
            p.validate_file(d)


class TestParseHappyPath:
    def test_parse_new_plan_and_cleanup(
        self, tmp_path: Path, monkeypatch: pytest.MonkeyPatch
    ) -> None:
        proj = tmp_path / "proj"
        proj.mkdir()
        (proj / "main.tf").write_text("# tf")

        calls: list[list[str]] = []

        def fake_run(args: list[str], **kwargs: Any):
            calls.append(list(args))
            if args[:2] == ["terraform", "version"]:
                return _FakeCompleted("Terraform v1.6.0\n")
            if args[:2] == ["terraform", "init"]:
                return _FakeCompleted("Init OK\n")
            if args[:2] == ["terraform", "plan"]:
                return _FakeCompleted("Plan OK\n")
            if args[:2] == ["terraform", "show"] and "-json" in args:
                payload = {"format_version": "1.0", "planned_values": {}}
                return _FakeCompleted(json.dumps(payload))
            raise AssertionError(f"unexpected call: {args}")

        monkeypatch.setattr("shutil.which", _fake_which)
        monkeypatch.setattr("subprocess.run", fake_run)

        p = TerraformParser()
        result = p.parse(proj)

        # expected result
        assert "format_version" in result
        # JSON cache written
        cache = proj / "terraform-plan.json"
        assert cache.exists()
        # no tfplan leftover generated by the parser
        assert not list(proj.glob("tf-parser-plan-*.tfplan"))
        # expected calls (version, init, plan, show)
        joined = [" ".join(c) for c in calls]
        assert any(c.startswith("terraform version") for c in joined)
        assert any(c.startswith("terraform init") for c in joined)
        assert any(c.startswith("terraform plan") for c in joined)
        assert any("terraform show -json" in c for c in joined)

    def test_parse_uses_existing_tfplan_only_show(
        self, tmp_path: Path, monkeypatch: pytest.MonkeyPatch
    ) -> None:
        proj = tmp_path / "proj"
        proj.mkdir()
        (proj / "main.tf").write_text("# tf")
        plan = proj / "existing.tfplan"
        plan.write_bytes(b"bin")

        calls: list[list[str]] = []

        def fake_run(args: list[str], **kwargs: Any):
            calls.append(list(args))
            if args[:2] == ["terraform", "version"]:
                return _FakeCompleted("Terraform v1.5.0\n")
            if args[:2] == ["terraform", "show"] and "-json" in args:
                payload = {"ok": True}
                return _FakeCompleted(json.dumps(payload))
            raise AssertionError(f"unexpected call: {args}")

        monkeypatch.setattr("shutil.which", _fake_which)
        monkeypatch.setattr("subprocess.run", fake_run)

        p = TerraformParser()
        res = p.parse(proj)
        assert res["ok"] is True

        joined = [" ".join(c) for c in calls]
        # should not call init/plan
        assert not any(c.startswith("terraform init") for c in joined)
        assert not any(c.startswith("terraform plan") for c in joined)
        assert any("terraform show -json" in c for c in joined)


class TestParseCacheAndErrors:
    def test_parse_uses_cached_json_plan(
        self, tmp_path: Path, monkeypatch: pytest.MonkeyPatch
    ) -> None:
        proj = tmp_path / "proj"
        proj.mkdir()
        (proj / "main.tf").write_text("# tf")
        cached = {"cached": True}
        (proj / "terraform-plan.json").write_text(json.dumps(cached), encoding="utf-8")

        def should_not_run(*a: Any, **k: Any):
            raise AssertionError("subprocess.run should not be called")

        monkeypatch.setattr("subprocess.run", should_not_run)
        p = TerraformParser()
        res = p.parse(proj)
        assert res == cached

    def test_binary_not_found_raises(
        self, tmp_path: Path, monkeypatch: pytest.MonkeyPatch
    ) -> None:
        proj = tmp_path / "proj"
        proj.mkdir()
        (proj / "main.tf").write_text("# tf")
        monkeypatch.setattr("shutil.which", lambda _: None)

        p = TerraformParser()
        with pytest.raises(RuntimeError, match="Terraform CLI .* not found"):
            p.parse(proj)

    def test_show_returns_non_json_bubbles_decode_error(
        self, tmp_path: Path, monkeypatch: pytest.MonkeyPatch
    ) -> None:
        proj = tmp_path / "proj"
        proj.mkdir()
        (proj / "main.tf").write_text("# tf")

        def fake_run(args: list[str], **kwargs: Any):
            if args[:2] == ["terraform", "version"]:
                return _FakeCompleted("Terraform v1.6.0\n")
            if args[:2] == ["terraform", "init"]:
                return _FakeCompleted("Init\n")
            if args[:2] == ["terraform", "plan"]:
                return _FakeCompleted("Plan\n")
            if args[:2] == ["terraform", "show"] and "-json" in args:
                return _FakeCompleted("not-a-json")
            raise AssertionError(f"unexpected call: {args}")

        monkeypatch.setattr("shutil.which", _fake_which)
        monkeypatch.setattr("subprocess.run", fake_run)

        p = TerraformParser()
        with pytest.raises(json.JSONDecodeError):
            p.parse(proj)

    def test_init_failure_raises_and_cleans_tmp_plan(
        self, tmp_path: Path, monkeypatch: pytest.MonkeyPatch
    ) -> None:
        proj = tmp_path / "proj"
        proj.mkdir()
        (proj / "main.tf").write_text("# tf")

        class _CPE(Exception):
            pass

        def fake_run(args: list[str], **kwargs: Any):
            if args[:2] == ["terraform", "version"]:
                return _FakeCompleted("v\n")
            if args[:2] == ["terraform", "init"]:
                # Simulate CalledProcessError raised by subprocess.run
                raise _CPE("init failed")
            raise AssertionError(f"unexpected call: {args}")

        monkeypatch.setattr("shutil.which", _fake_which)
        monkeypatch.setattr("subprocess.run", fake_run)

        p = TerraformParser()
        with pytest.raises(_CPE):
            p.parse(proj)
        # no tfplan leftover
        assert not list(proj.glob("tf-parser-plan-*.tfplan"))


class TestUtilityMethods:
    def test_run_command_timeout_raises_runtime(
        self, tmp_path: Path, monkeypatch: pytest.MonkeyPatch
    ) -> None:
        from subprocess import TimeoutExpired

        def fake_run(*a: Any, **k: Any):
            raise TimeoutExpired(cmd="terraform X", timeout=1)

        monkeypatch.setattr("subprocess.run", fake_run)
        p = TerraformParser()
        with pytest.raises(RuntimeError, match="Command timeout"):
            p._run_command(["terraform", "plan"], cwd=tmp_path, timeout=1)

    def test_check_terraform_timeout_raises_runtime(
        self, tmp_path: Path, monkeypatch: pytest.MonkeyPatch
    ) -> None:
        from subprocess import TimeoutExpired

        monkeypatch.setattr("shutil.which", _fake_which)

        def fake_run(*a: Any, **k: Any):
            raise TimeoutExpired(cmd="terraform version", timeout=10)

        monkeypatch.setattr("subprocess.run", fake_run)
        p = TerraformParser()
        with pytest.raises(RuntimeError, match="Timeout during Terraform check"):
            p._check_terraform_binary()

    def test_not_applicable_methods_raise(self, tmp_path: Path) -> None:
        p = TerraformParser()
        with pytest.raises(NotImplementedError):
            p._read_file(tmp_path / "x.tf")
        with pytest.raises(NotImplementedError):
            p._parse_content("x", tmp_path / "x.tf")

    def test_clear_plan_cache(
        self, tmp_path: Path, caplog: pytest.LogCaptureFixture
    ) -> None:
        caplog.set_level("INFO")
        proj = tmp_path / "proj"
        proj.mkdir()
        cache = proj / "terraform-plan.json"
        cache.write_text("{}", encoding="utf-8")

        p = TerraformParser()
        assert p.clear_plan_cache(proj) is True
        assert not cache.exists()
        assert any("Cleared cached JSON plan" in r.message for r in caplog.records)

    def test_clear_plan_cache_when_absent(self, tmp_path: Path) -> None:
        proj = tmp_path / "proj"
        proj.mkdir()
        p = TerraformParser()
        assert p.clear_plan_cache(proj) is False
