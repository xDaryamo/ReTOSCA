import inspect
import logging
from typing import TYPE_CHECKING, Any

from src.core.common.base_mapper import BaseResourceMapper
from src.core.protocols import SingleResourceMapper
from src.plugins.terraform.mapper import TerraformMapper

if TYPE_CHECKING:
    from src.models.v2_0.builder import ServiceTemplateBuilder


logger = logging.getLogger(__name__)


class AWSSecurityGroupMapper(SingleResourceMapper):
    """
    Map a Terraform 'aws_security_group' resource into a tosca.nodes.Root node.

    Because there is no standard TOSCA type for security groups in the simple
    profile, we use the Root type and store the relevant information in
    metadata.
    """

    def can_map(self, resource_type: str, resource_data: dict[str, Any]) -> bool:
        """This mapper is specific to the 'aws_security_group' resource type."""
        return resource_type == "aws_security_group"

    def map_resource(
        self,
        resource_name: str,
        resource_type: str,
        resource_data: dict[str, Any],
        builder: "ServiceTemplateBuilder",
    ) -> None:
        """
        Perform translation from aws_security_group to tosca.nodes.Root.

        Args:
            resource_name: Resource name (e.g. 'aws_security_group.allow_tls')
            resource_type: Resource type (always 'aws_security_group')
            resource_data: Resource data from the Terraform plan
            builder: Builder used to construct the TOSCA service template
        """
        logger.info(f"Mapping Security Group resource: '{resource_name}'")

        # Validate input data
        values = resource_data.get("values", {})
        if not values:
            logger.warning(
                f"Resource '{resource_name}' has no 'values' section. Skipping."
            )
            return

        # Generate a unique TOSCA node name using the utility function
        node_name = BaseResourceMapper.generate_tosca_node_name(
            resource_name, resource_type
        )

        # Extract the clean name for metadata (without the type prefix)
        if "." in resource_name:
            _, clean_name = resource_name.split(".", 1)
        else:
            clean_name = resource_name

        # Create the Root node to represent the security group
        sg_node = builder.add_node(name=node_name, node_type="Root")

        # Build full metadata containing Terraform and AWS information
        metadata: dict[str, Any] = {}

        # Original resource information
        metadata["original_resource_type"] = resource_type
        metadata["original_resource_name"] = clean_name

        # Information from resource_data if available
        provider_name = resource_data.get("provider_name")
        if provider_name:
            metadata["aws_provider"] = provider_name

        # === Main properties of the Security Group ===

        # Security group name
        sg_name = values.get("name")
        if sg_name:
            metadata["aws_security_group_name"] = sg_name

        # Security group description
        description = values.get("description")
        if description:
            metadata["aws_description"] = description

        # VPC ID membership
        vpc_id = values.get("vpc_id")
        if vpc_id:
            metadata["aws_vpc_id"] = vpc_id

        # Security group ARN
        arn = values.get("arn")
        if arn:
            metadata["aws_arn"] = arn

        # Security group ID (generated by AWS)
        sg_id = values.get("id")
        if sg_id:
            metadata["aws_security_group_id"] = sg_id

        # Owner ID
        owner_id = values.get("owner_id")
        if owner_id:
            metadata["aws_owner_id"] = owner_id

        # === Optional configurations ===

        # Revoke rules on delete
        revoke_rules_on_delete = values.get("revoke_rules_on_delete")
        if revoke_rules_on_delete is not None:
            metadata["aws_revoke_rules_on_delete"] = revoke_rules_on_delete

        # Name prefix (if specified)
        name_prefix = values.get("name_prefix")
        if name_prefix:
            metadata["aws_name_prefix"] = name_prefix

        # Security group tags
        tags = values.get("tags", {})
        if tags:
            metadata["aws_tags"] = tags

        # Tags_all (including provider defaults)
        tags_all = values.get("tags_all", {})
        if tags_all and tags_all != tags:
            metadata["aws_tags_all"] = tags_all

        # Attach all metadata to the node
        sg_node.with_metadata(metadata)

        # VPC dependency detection
        vpc_dependency_added = False
        # Find the current instance of the TerraformMapper
        for frame_info in inspect.stack():
            frame_locals = frame_info.frame.f_locals
            if "self" in frame_locals and isinstance(
                frame_locals["self"], TerraformMapper
            ):
                terraform_mapper = frame_locals["self"]
                parsed_data = terraform_mapper.get_current_parsed_data()
                break
        else:
            parsed_data = {}
            logger.warning(
                "Unable to access Terraform plan data to detect requirements"
            )

        if parsed_data:
            terraform_refs = TerraformMapper.extract_terraform_references(
                resource_data, parsed_data
            )
            for prop_name, target_ref, relationship_type in terraform_refs:
                # Only for VPC and only if not already added
                if prop_name == "vpc_id" and not vpc_dependency_added:
                    if "." in target_ref:
                        # target_ref is already in the format "aws_vpc.main"
                        # Extract only the type for the second parameter
                        target_resource_type = target_ref.split(".", 1)[0]
                        target_node_name = BaseResourceMapper.generate_tosca_node_name(
                            target_ref, target_resource_type
                        )

                        # Add the requirement using the builder pattern
                        sg_node.add_requirement("dependency").to_node(
                            target_node_name
                        ).with_relationship(relationship_type).and_node()

                        vpc_dependency_added = True
                        logger.info(
                            "Added dependency %s to '%s' for VPC",
                            relationship_type,
                            target_node_name,
                        )
                        break  # Only one VPC dependency

        logger.debug(f"Root Security Group node '{node_name}' created successfully.")

        # Log mapped properties for debugging
        logger.debug(
            "Mapped properties for '%s':\n"
            "  - Name: %s\n"
            "  - Description: %s\n"
            "  - VPC ID: %s\n"
            "  - Tags: %s",
            node_name,
            sg_name,
            description,
            vpc_id,
            tags,
        )
