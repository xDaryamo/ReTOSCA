import logging
from typing import TYPE_CHECKING, Any

from src.core.common.base_mapper import BaseResourceMapper
from src.core.protocols import SingleResourceMapper

if TYPE_CHECKING:
    from src.models.v2_0.builder import ServiceTemplateBuilder
    from src.plugins.terraform.context import TerraformMappingContext


logger = logging.getLogger(__name__)


class AWSSecurityGroupMapper(SingleResourceMapper):
    """
    Map a Terraform 'aws_security_group' resource into a tosca.nodes.Root node.

    Because there is no standard TOSCA type for security groups in the simple
    profile, we use the Root type and store the relevant information in
    metadata.
    """

    def can_map(self, resource_type: str, resource_data: dict[str, Any]) -> bool:
        """This mapper is specific to the 'aws_security_group' resource type."""
        return resource_type == "aws_security_group"

    def map_resource(
        self,
        resource_name: str,
        resource_type: str,
        resource_data: dict[str, Any],
        builder: "ServiceTemplateBuilder",
        context: "TerraformMappingContext | None" = None,
    ) -> None:
        """
        Perform translation from aws_security_group to tosca.nodes.Root.

        Args:
            resource_name: Resource name (e.g. 'aws_security_group.allow_tls')
            resource_type: Resource type (always 'aws_security_group')
            resource_data: Resource data from the Terraform plan
            builder: Builder used to construct the TOSCA service template
        """
        logger.info(f"Mapping Security Group resource: '{resource_name}'")

        # Validate input data
        values = resource_data.get("values", {})
        if not values:
            logger.warning(
                f"Resource '{resource_name}' has no 'values' section. Skipping."
            )
            return

        # Generate a unique TOSCA node name using the utility function
        node_name = BaseResourceMapper.generate_tosca_node_name(
            resource_name, resource_type
        )

        # Extract the clean name for metadata (without the type prefix)
        if "." in resource_name:
            _, clean_name = resource_name.split(".", 1)
        else:
            clean_name = resource_name

        # Create the Root node to represent the security group
        sg_node = builder.add_node(name=node_name, node_type="Root")

        # Build full metadata containing Terraform and AWS information
        metadata: dict[str, Any] = {}

        # Original resource information
        metadata["original_resource_type"] = resource_type
        metadata["original_resource_name"] = clean_name

        # Information from resource_data if available
        provider_name = resource_data.get("provider_name")
        if provider_name:
            metadata["aws_provider"] = provider_name

        # === Main properties of the Security Group ===

        # Security group name
        sg_name = values.get("name")
        if sg_name:
            metadata["aws_security_group_name"] = sg_name

        # Security group description
        description = values.get("description")
        if description:
            metadata["aws_description"] = description

        # VPC ID membership
        vpc_id = values.get("vpc_id")
        if vpc_id:
            metadata["aws_vpc_id"] = vpc_id

        # Security group ARN
        arn = values.get("arn")
        if arn:
            metadata["aws_arn"] = arn

        # Security group ID (generated by AWS)
        sg_id = values.get("id")
        if sg_id:
            metadata["aws_security_group_id"] = sg_id

        # Owner ID
        owner_id = values.get("owner_id")
        if owner_id:
            metadata["aws_owner_id"] = owner_id

        # === Optional configurations ===

        # Revoke rules on delete
        revoke_rules_on_delete = values.get("revoke_rules_on_delete")
        if revoke_rules_on_delete is not None:
            metadata["aws_revoke_rules_on_delete"] = revoke_rules_on_delete

        # Name prefix (if specified)
        name_prefix = values.get("name_prefix")
        if name_prefix:
            metadata["aws_name_prefix"] = name_prefix

        # Security group tags
        tags = values.get("tags", {})
        if tags:
            metadata["aws_tags"] = tags

        # Tags_all (including provider defaults)
        tags_all = values.get("tags_all", {})
        if tags_all and tags_all != tags:
            metadata["aws_tags_all"] = tags_all

        # === Security Group Rules ===

        # Ingress rules
        ingress_rules = values.get("ingress", [])
        if ingress_rules:
            processed_ingress = []
            for rule in ingress_rules:
                rule_data = {
                    "from_port": rule.get("from_port"),
                    "to_port": rule.get("to_port"),
                    "protocol": rule.get("protocol"),
                }

                # Add description if available
                if rule.get("description"):
                    rule_data["description"] = rule.get("description")

                # Add CIDR blocks if available
                if rule.get("cidr_blocks"):
                    rule_data["cidr_blocks"] = rule.get("cidr_blocks")

                # Add IPv6 CIDR blocks if available
                if rule.get("ipv6_cidr_blocks"):
                    rule_data["ipv6_cidr_blocks"] = rule.get("ipv6_cidr_blocks")

                # Add prefix list IDs if available
                if rule.get("prefix_list_ids"):
                    rule_data["prefix_list_ids"] = rule.get("prefix_list_ids")

                # Add security groups if available
                if rule.get("security_groups"):
                    rule_data["security_groups"] = rule.get("security_groups")

                # Add self reference if available
                if rule.get("self") is not None:
                    rule_data["self"] = rule.get("self")

                processed_ingress.append(rule_data)

            metadata["aws_ingress_rules"] = processed_ingress

        # Egress rules
        egress_rules = values.get("egress", [])
        if egress_rules:
            processed_egress = []
            for rule in egress_rules:
                rule_data = {
                    "from_port": rule.get("from_port"),
                    "to_port": rule.get("to_port"),
                    "protocol": rule.get("protocol"),
                }

                # Add description if available
                if rule.get("description"):
                    rule_data["description"] = rule.get("description")

                # Add CIDR blocks if available
                if rule.get("cidr_blocks"):
                    rule_data["cidr_blocks"] = rule.get("cidr_blocks")

                # Add IPv6 CIDR blocks if available
                if rule.get("ipv6_cidr_blocks"):
                    rule_data["ipv6_cidr_blocks"] = rule.get("ipv6_cidr_blocks")

                # Add prefix list IDs if available
                if rule.get("prefix_list_ids"):
                    rule_data["prefix_list_ids"] = rule.get("prefix_list_ids")

                # Add security groups if available
                if rule.get("security_groups"):
                    rule_data["security_groups"] = rule.get("security_groups")

                # Add self reference if available
                if rule.get("self") is not None:
                    rule_data["self"] = rule.get("self")

                processed_egress.append(rule_data)

            metadata["aws_egress_rules"] = processed_egress

        # Count rules for quick reference
        metadata["aws_ingress_rule_count"] = len(ingress_rules)
        metadata["aws_egress_rule_count"] = len(egress_rules)

        # Attach all metadata to the node
        sg_node.with_metadata(metadata)

        # Add dependencies using injected context
        if context:
            terraform_refs = context.extract_terraform_references(resource_data)
            logger.debug(
                f"Found {len(terraform_refs)} terraform references for {resource_name}"
            )

            for prop_name, target_ref, relationship_type in terraform_refs:
                logger.debug(
                    "Processing reference: %s -> %s (%s)",
                    prop_name,
                    target_ref,
                    relationship_type,
                )

                if "." in target_ref:
                    # target_ref is like "aws_vpc.main"
                    target_resource_type = target_ref.split(".", 1)[0]
                    target_node_name = BaseResourceMapper.generate_tosca_node_name(
                        target_ref, target_resource_type
                    )

                    # Add requirement with the property name as the requirement name
                    requirement_name = (
                        prop_name if prop_name not in ["dependency"] else "dependency"
                    )

                    (
                        sg_node.add_requirement(requirement_name)
                        .to_node(target_node_name)
                        .with_relationship(relationship_type)
                        .and_node()
                    )

                    logger.info(
                        "Added %s requirement '%s' to '%s' with relationship %s",
                        requirement_name,
                        target_node_name,
                        node_name,
                        relationship_type,
                    )
        else:
            logger.warning(
                "No context provided to detect dependencies for resource '%s'",
                resource_name,
            )

        logger.debug(f"Root Security Group node '{node_name}' created successfully.")

        # Log mapped properties for debugging
        logger.debug(
            "Mapped properties for '%s':\n"
            "  - Name: %s\n"
            "  - Description: %s\n"
            "  - VPC ID: %s\n"
            "  - Tags: %s\n"
            "  - Ingress rules: %d\n"
            "  - Egress rules: %d",
            node_name,
            sg_name,
            description,
            vpc_id,
            tags,
            len(ingress_rules),
            len(egress_rules),
        )
