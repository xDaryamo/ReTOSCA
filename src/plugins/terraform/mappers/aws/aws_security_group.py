import inspect
import logging
from typing import TYPE_CHECKING, Any

from src.core.common.base_mapper import BaseResourceMapper
from src.core.protocols import SingleResourceMapper
from src.plugins.terraform.mapper import TerraformMapper

if TYPE_CHECKING:
    from src.models.v2_0.builder import ServiceTemplateBuilder


logger = logging.getLogger(__name__)


class AWSSecurityGroupMapper(SingleResourceMapper):
    """
    Map a Terraform 'aws_security_group' resource into a tosca.nodes.Root node.

    Because there is no standard TOSCA type for security groups in the simple
    profile, we use the Root type and store the relevant information in
    metadata.
    """

    def can_map(self, resource_type: str, resource_data: dict[str, Any]) -> bool:
        """This mapper is specific to the 'aws_security_group' resource type."""
        return resource_type == "aws_security_group"

    def map_resource(
        self,
        resource_name: str,
        resource_type: str,
        resource_data: dict[str, Any],
        builder: "ServiceTemplateBuilder",
    ) -> None:
        """
        Perform translation from aws_security_group to tosca.nodes.Root.

        Args:
            resource_name: Resource name (e.g. 'aws_security_group.allow_tls')
            resource_type: Resource type (always 'aws_security_group')
            resource_data: Resource data from the Terraform plan
            builder: Builder used to construct the TOSCA service template
        """
        logger.info(f"Mapping Security Group resource: '{resource_name}'")

        # Validate input data
        values = resource_data.get("values", {})
        if not values:
            logger.warning(
                f"Resource '{resource_name}' has no 'values' section. Skipping."
            )
            return

        # Generate a unique TOSCA node name using the utility function
        node_name = BaseResourceMapper.generate_tosca_node_name(
            resource_name, resource_type
        )

        # Extract the clean name for metadata (without the type prefix)
        if "." in resource_name:
            _, clean_name = resource_name.split(".", 1)
        else:
            clean_name = resource_name

        # Create the Root node to represent the security group
        sg_node = builder.add_node(name=node_name, node_type="Root")

        # Build full metadata containing Terraform and AWS information
        metadata: dict[str, Any] = {}

        # Original resource information
        metadata["original_resource_type"] = resource_type
        metadata["original_resource_name"] = clean_name

        # Information from resource_data if available
        provider_name = resource_data.get("provider_name")
        if provider_name:
            metadata["aws_provider"] = provider_name

        # === Main properties of the Security Group ===

        # Security group name
        sg_name = values.get("name")
        if sg_name:
            metadata["aws_security_group_name"] = sg_name

        # Security group description
        description = values.get("description")
        if description:
            metadata["aws_description"] = description

        # VPC ID membership
        vpc_id = values.get("vpc_id")
        if vpc_id:
            metadata["aws_vpc_id"] = vpc_id

        # Security group ARN
        arn = values.get("arn")
        if arn:
            metadata["aws_arn"] = arn

        # Security group ID (generated by AWS)
        sg_id = values.get("id")
        if sg_id:
            metadata["aws_security_group_id"] = sg_id

        # Owner ID
        owner_id = values.get("owner_id")
        if owner_id:
            metadata["aws_owner_id"] = owner_id

        # === Ingress rules ===
        ingress_rules = values.get("ingress", [])
        if ingress_rules:
            metadata["aws_ingress_rules"] = []
            for _i, rule in enumerate(ingress_rules):
                rule_metadata = {
                    "from_port": rule.get("from_port"),
                    "to_port": rule.get("to_port"),
                    "protocol": rule.get("protocol"),
                    "description": rule.get("description", ""),
                    "cidr_blocks": rule.get("cidr_blocks", []),
                    "ipv6_cidr_blocks": rule.get("ipv6_cidr_blocks", []),
                    "prefix_list_ids": rule.get("prefix_list_ids", []),
                    "security_groups": rule.get("security_groups", []),
                    "self": rule.get("self", False),
                }
                metadata["aws_ingress_rules"].append(rule_metadata)

        # === Egress rules ===
        egress_rules = values.get("egress", [])
        if egress_rules:
            metadata["aws_egress_rules"] = []
            for _i, rule in enumerate(egress_rules):
                rule_metadata = {
                    "from_port": rule.get("from_port"),
                    "to_port": rule.get("to_port"),
                    "protocol": rule.get("protocol"),
                    "description": rule.get("description", ""),
                    "cidr_blocks": rule.get("cidr_blocks", []),
                    "ipv6_cidr_blocks": rule.get("ipv6_cidr_blocks", []),
                    "prefix_list_ids": rule.get("prefix_list_ids", []),
                    "security_groups": rule.get("security_groups", []),
                    "self": rule.get("self", False),
                }
                metadata["aws_egress_rules"].append(rule_metadata)

        # === Optional configurations ===

        # Revoke rules on delete
        revoke_rules_on_delete = values.get("revoke_rules_on_delete")
        if revoke_rules_on_delete is not None:
            metadata["aws_revoke_rules_on_delete"] = revoke_rules_on_delete

        # Name prefix (if specified)
        name_prefix = values.get("name_prefix")
        if name_prefix:
            metadata["aws_name_prefix"] = name_prefix

        # Security group tags
        tags = values.get("tags", {})
        if tags:
            metadata["aws_tags"] = tags

        # Tags_all (including provider defaults)
        tags_all = values.get("tags_all", {})
        if tags_all and tags_all != tags:
            metadata["aws_tags_all"] = tags_all

        # Attach all metadata to the node
        sg_node.with_metadata(metadata)

        # Collect all ingress/egress rules from the Terraform plan
        # Find the current instance of the TerraformMapper
        for frame_info in inspect.stack():
            frame_locals = frame_info.frame.f_locals
            if "self" in frame_locals and isinstance(
                frame_locals["self"], TerraformMapper
            ):
                terraform_mapper = frame_locals["self"]
                parsed_data = terraform_mapper.get_current_parsed_data()
                break
        else:
            parsed_data = {}
            logger.warning(
                "Unable to access Terraform plan data to detect requirements"
            )

        # Collect ingress and egress rules from separate resources
        ingress_rules_metadata = []
        egress_rules_metadata = []

        if parsed_data:
            # Search planned_values for security rules
            planned_values = parsed_data.get("planned_values", {})
            root_module = planned_values.get("root_module", {})
            resources = root_module.get("resources", [])

            # Also search configuration for references
            configuration = parsed_data.get("configuration", {})
            config_root_module = configuration.get("root_module", {})
            config_resources = config_root_module.get("resources", [])

            for resource in resources:
                resource_type = resource.get("type", "")
                resource_address = resource.get("address", "")
                resource_values = resource.get("values", {})

                # Find the matching configuration resource for references
                config_resource = None
                for config_res in config_resources:
                    if config_res.get("address") == resource_address:
                        config_resource = config_res
                        break

                config_expressions = (
                    config_resource.get("expressions", {}) if config_resource else {}
                )

                # Ingress rules
                if resource_type == "aws_vpc_security_group_ingress_rule":
                    # Extract clean rule name
                    rule_name = (
                        resource_address.split(".")[-1]
                        if "." in resource_address
                        else resource_address
                    )

                    # Check if this rule belongs to our security group
                    sg_ref = config_expressions.get("security_group_id", {}).get(
                        "references", []
                    )
                    if sg_ref and any(
                        f"aws_security_group.{clean_name}" in ref for ref in sg_ref
                    ):
                        rule_metadata = {
                            "rule_id": rule_name,
                            "from_port": resource_values.get("from_port"),
                            "to_port": resource_values.get("to_port"),
                            "protocol": resource_values.get("ip_protocol"),
                            "description": resource_values.get("description"),
                        }

                        # Add CIDR blocks
                        if resource_values.get("cidr_ipv4"):
                            rule_metadata["cidr_ipv4"] = resource_values["cidr_ipv4"]
                        if resource_values.get("cidr_ipv6"):
                            rule_metadata["cidr_ipv6"] = resource_values["cidr_ipv6"]

                        # Check for references in config expressions
                        cidr_ipv4_refs = config_expressions.get("cidr_ipv4", {}).get(
                            "references", []
                        )
                        if cidr_ipv4_refs:
                            rule_metadata["cidr_ipv4_ref"] = cidr_ipv4_refs[0]

                        cidr_ipv6_refs = config_expressions.get("cidr_ipv6", {}).get(
                            "references", []
                        )
                        if cidr_ipv6_refs:
                            rule_metadata["cidr_ipv6_ref"] = cidr_ipv6_refs[0]

                        # Other optional fields
                        if resource_values.get("prefix_list_id"):
                            rule_metadata["prefix_list_id"] = resource_values[
                                "prefix_list_id"
                            ]
                        if resource_values.get("referenced_security_group_id"):
                            rule_metadata["referenced_security_group_id"] = (
                                resource_values["referenced_security_group_id"]
                            )

                        ingress_rules_metadata.append(rule_metadata)

                # Egress rules
                elif resource_type == "aws_vpc_security_group_egress_rule":
                    # Extract clean rule name
                    rule_name = (
                        resource_address.split(".")[-1]
                        if "." in resource_address
                        else resource_address
                    )

                    # Check if this rule belongs to our security group
                    sg_ref = config_expressions.get("security_group_id", {}).get(
                        "references", []
                    )
                    if sg_ref and any(
                        f"aws_security_group.{clean_name}" in ref for ref in sg_ref
                    ):
                        rule_metadata = {
                            "rule_id": rule_name,
                            "from_port": resource_values.get("from_port"),
                            "to_port": resource_values.get("to_port"),
                            "protocol": resource_values.get("ip_protocol"),
                            "description": resource_values.get("description"),
                        }

                        # Add CIDR blocks
                        if resource_values.get("cidr_ipv4"):
                            rule_metadata["cidr_ipv4"] = resource_values["cidr_ipv4"]
                        if resource_values.get("cidr_ipv6"):
                            rule_metadata["cidr_ipv6"] = resource_values["cidr_ipv6"]

                        # Check for references in config expressions
                        cidr_ipv4_refs = config_expressions.get("cidr_ipv4", {}).get(
                            "references", []
                        )
                        if cidr_ipv4_refs:
                            rule_metadata["cidr_ipv4_ref"] = cidr_ipv4_refs[0]

                        cidr_ipv6_refs = config_expressions.get("cidr_ipv6", {}).get(
                            "references", []
                        )
                        if cidr_ipv6_refs:
                            rule_metadata["cidr_ipv6_ref"] = cidr_ipv6_refs[0]

                        # Other optional fields
                        if resource_values.get("prefix_list_id"):
                            rule_metadata["prefix_list_id"] = resource_values[
                                "prefix_list_id"
                            ]
                        if resource_values.get("referenced_security_group_id"):
                            rule_metadata["referenced_security_group_id"] = (
                                resource_values["referenced_security_group_id"]
                            )

                        egress_rules_metadata.append(rule_metadata)

        # Attach collected rules to metadata
        if ingress_rules_metadata:
            metadata["ingress_rules"] = ingress_rules_metadata
            logger.info(
                "Found %d ingress rules for Security Group '%s',",
                len(ingress_rules_metadata),
                clean_name,
            )

        if egress_rules_metadata:
            metadata["egress_rules"] = egress_rules_metadata
            logger.info(
                "Found %d egress rules for Security Group '%s',",
                len(egress_rules_metadata),
                clean_name,
            )

        # VPC dependency detection
        vpc_dependency_added = False
        if parsed_data:
            terraform_refs = TerraformMapper.extract_terraform_references(
                resource_data, parsed_data
            )
            for prop_name, target_ref, relationship_type in terraform_refs:
                # Only for VPC and only if not already added
                if prop_name == "vpc_id" and not vpc_dependency_added:
                    if "." in target_ref:
                        # target_ref is already in the format "aws_vpc.main"
                        # Extract only the type for the second parameter
                        target_resource_type = target_ref.split(".", 1)[0]
                        target_node_name = BaseResourceMapper.generate_tosca_node_name(
                            target_ref, target_resource_type
                        )

                        # Add the requirement using the builder pattern
                        sg_node.add_requirement("dependency").to_node(
                            target_node_name
                        ).with_relationship(relationship_type).and_node()

                        vpc_dependency_added = True
                        logger.info(
                            "Added dependency %s to '%s' for VPC",
                            relationship_type,
                            target_node_name,
                        )
                        break  # Only one VPC dependency

        logger.debug(f"Root Security Group node '{node_name}' created successfully.")

        # Log mapped properties for debugging
        logger.debug(
            "Mapped properties for '%s':\n"
            "  - Name: %s\n"
            "  - Description: %s\n"
            "  - VPC ID: %s\n"
            "  - Ingress rules (legacy): %d\n"
            "  - Egress rules (legacy): %d\n"
            "  - Ingress rules (separate): %d\n"
            "  - Egress rules (separate): %d\n"
            "  - Tags: %s",
            node_name,
            sg_name,
            description,
            vpc_id,
            len(ingress_rules) if ingress_rules else 0,
            len(egress_rules) if egress_rules else 0,
            len(ingress_rules_metadata),
            len(egress_rules_metadata),
            tags,
        )
