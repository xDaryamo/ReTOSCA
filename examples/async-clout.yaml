version: "1.0"
metadata:
  history:
    - description: compile
      timestamp: "2025-07-15T16:23:33.718009799+02:00"
    - description: resolve
      timestamp: "2025-07-15T16:23:33.731678663+02:00"
    - description: coerce
      timestamp: "2025-07-15T16:23:33.739633533+02:00"
  puccini:
    scriptlets:
      tosca:
        coerce: |-
          const traversal = require('tosca.lib.traversal');
          const tosca = require('tosca.lib.utils');

          traversal.coerce();
          if (env.arguments.history !== 'false')
            tosca.addHistory('coerce');
          transcribe.output(clout);
        comparer:
          version: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.2.2
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.2.2
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.2.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.2.2

            exports.compare = function(a, b) {
              if (a.$comparer !== b.$comparer)
                throw 'both values must be of type "version"';
              if (a.major !== b.major)
                return a.major < b.major ? -1 : 1;
              if (a.minor !== b.minor)
                return a.minor < b.minor ? -1 : 1;
              if (a.fix !== b.fix)
                return a.fix < b.fix ? -1 : 1;
              let aq = a.qualifier.toLowerCase();
              let bq = b.qualifier.toLowerCase();
              if (aq !== bq) // note: the qualifier is compared alphabetically, *not* semantically
                return aq < bq ? -1 : 1;
              if (a.build !== b.build)
                return a.build < b.build ? -1 : 1;
              return 0;
            };
        function:
          $get_target_name: |-
            const tosca = require('tosca.lib.utils');

            exports.evaluate = function() {
              if (!this || !this.target)
                throw 'TARGET cannot be used in this context';
              if (!tosca.isNodeTemplate(this.target))
                throw 'TARGET is not a node template';
              return this.target.properties.name;
            };
          ceil: "// [TOSCA-v2.0] @ 10.2.5.8\n\nexports.evaluate = function() {\n    if (arguments.length !== 1) {\n        throw 'The $ceil function expects exactly one argument.';\n    }\n    \n    let arg = arguments[0];\n    \n    // Process the argument - must be float or number\n    let floatValue = 0;\n    \n    // Case 1: JavaScript number\n    if (typeof arg === 'number') {\n        floatValue = arg;\n    }\n    // Case 2: TOSCA float object\n    else if (arg !== null && typeof arg === 'object' && arg.hasOwnProperty('$float')) {\n        let value = arg.$float;\n        if (typeof value === 'number') {\n            floatValue = value;\n        } else {\n            throw 'The $ceil function float argument must be a number; got ' + (typeof value);\n        }\n    }\n    // Case 3: TOSCA integer object (can be converted to float)\n    else if (arg !== null && typeof arg === 'object' && arg.hasOwnProperty('$integer')) {\n        let intValue = arg.$integer;\n        if (typeof intValue === 'number' && Number.isInteger(intValue)) {\n            floatValue = parseFloat(intValue);\n        } else {\n            throw 'The $ceil function integer argument must be an integer; got ' + (typeof intValue);\n        }\n    }\n    // Case 4: Puccini's scalar representation with numeric value\n    else if (arg !== null && typeof arg === 'object' && arg.hasOwnProperty('scalar') && typeof arg.scalar === 'number') {\n        floatValue = arg.scalar;\n    }\n    // Case 5: Puccini's alternate format with $number\n    else if (arg !== null && typeof arg === 'object' && arg.hasOwnProperty('$number') && typeof arg.$number === 'number') {\n        floatValue = arg.$number;\n    }\n    else {\n        throw 'The $ceil function argument must be a float or number type; got ' + (typeof arg);\n    }\n    \n    // Apply ceil function and normalize -0 to 0\n    let result = Math.ceil(floatValue);\n    return result === 0 ? 0 : result;  // Converte -0 in 0\n};"
          concat: "// [TOSCA-Simple-Profile-YAML-v1.3] @ 4.3.1\n// [TOSCA-Simple-Profile-YAML-v1.2] @ 4.3.1\n// [TOSCA-Simple-Profile-YAML-v1.1] @ 4.3.1\n// [TOSCA-Simple-Profile-YAML-v1.0] @ 4.3.1\n\n// TOSCA 1.3/2.0 compatible $concat function\n// TOSCA 1.3: Allows implicit conversion of compatible types to strings\n// TOSCA 2.0: Strict type checking with no implicit conversion\n\nexports.evaluate = function() {\n    if (arguments.length === 0) {\n        throw new Error('$concat function requires at least one argument');\n    }\n\n    // Check first argument to determine expected type\n    let firstArg = arguments[0];\n    \n    // Handle scalar objects with $string property\n    if (firstArg && typeof firstArg === 'object' && firstArg.$string !== undefined) {\n        firstArg = firstArg.$string;\n    }\n    \n    const isFirstArgString = typeof firstArg === 'string';\n    const isFirstArgNumber = typeof firstArg === 'number';\n    const isFirstArgArray = Array.isArray(firstArg);\n    \n    // For TOSCA 1.3 compatibility: treat numbers as strings for concatenation\n    const isStringConcatenation = isFirstArgString || isFirstArgNumber;\n    \n    if (!isStringConcatenation && !isFirstArgArray) {\n        throw new Error('$concat function arguments must be all of type string/number or all of type list, got: ' + \n                       (typeof firstArg) + ' for first argument');\n    }\n    \n    if (isStringConcatenation) {\n        // String concatenation mode (TOSCA 1.3 compatible)\n        let result = [];\n        \n        for (let i = 0; i < arguments.length; i++) {\n            let argument = arguments[i];\n            \n            // Handle scalar objects with $string property\n            if (argument && typeof argument === 'object' && argument.$string !== undefined) {\n                argument = argument.$string;\n            } else if (argument && typeof argument === 'object' && argument.$number !== undefined) {\n                // Handle scalar numbers\n                argument = argument.$number;\n            }\n            \n            // TOSCA 1.3: Allow implicit conversion of compatible types\n            if (typeof argument === 'string') {\n                result.push(argument);\n            } else if (typeof argument === 'number') {\n                // Implicit conversion: number to string\n                result.push(String(argument));\n            } else if (typeof argument === 'boolean') {\n                // Implicit conversion: boolean to string\n                result.push(String(argument));\n            } else if (argument === null || argument === undefined) {\n                // Handle null/undefined as empty string\n                result.push('');\n            } else {\n                throw new Error('$concat function with string arguments cannot accept argument of type: ' + \n                               (typeof argument) + ' at position ' + i + \n                               '. Supported types: string, number, boolean.');\n            }\n        }\n        \n        return result.join('');\n        \n    } else if (isFirstArgArray) {\n        // List concatenation mode\n        let result = [];\n        \n        for (let i = 0; i < arguments.length; i++) {\n            let argument = arguments[i];\n            \n            if (!Array.isArray(argument)) {\n                throw new Error('$concat function with list arguments cannot accept argument of type: ' + \n                               (typeof argument) + ' at position ' + i + \n                               '. All arguments must be lists.');\n            }\n            \n            // Concatenate array elements\n            result = result.concat(argument);\n        }\n        \n        return result;\n    }\n    \n    // This should never be reached, but added for completeness\n    throw new Error('$concat function: invalid argument types detected');\n};"
          difference: "// [TOSCA-v2.0] @ 10.2.5.2\n\nexports.evaluate = function() {\n    if (arguments.length !== 2) {\n        throw 'The $difference function expects exactly two arguments.';\n    }\n    \n    let arg1 = arguments[0];\n    let arg2 = arguments[1];\n    let resultType = 'integer'; // Start with integer, upgrade to float if needed\n    \n    // Process first argument\n    let value1 = 0;\n    if (typeof arg1 === 'number') {\n        value1 = arg1;\n        if (!Number.isInteger(arg1)) {\n            resultType = 'float';\n        }\n    } else if (arg1 !== null && typeof arg1 === 'object' && arg1.hasOwnProperty('$scalar')) {\n        // TOSCA scalar type with unit\n        let scalarValue = arg1.$scalar;\n        if (typeof scalarValue === 'number') {\n            value1 = scalarValue;\n            if (!Number.isInteger(scalarValue)) {\n                resultType = 'float';\n            }\n        } else {\n            throw 'The $difference function first argument scalar must have a numeric value; got ' + (typeof scalarValue);\n        }\n    } else if (arg1 !== null && typeof arg1 === 'object' && arg1.hasOwnProperty('$integer')) {\n        // TOSCA integer type\n        let intValue = arg1.$integer;\n        if (typeof intValue === 'number' && Number.isInteger(intValue)) {\n            value1 = intValue;\n        } else {\n            throw 'The $difference function first argument integer must be an integer; got ' + (typeof intValue);\n        }\n    } else if (arg1 !== null && typeof arg1 === 'object' && arg1.hasOwnProperty('$float')) {\n        // TOSCA float type\n        let floatValue = arg1.$float;\n        if (typeof floatValue === 'number') {\n            value1 = floatValue;\n            resultType = 'float';\n        } else {\n            throw 'The $difference function first argument float must be a number; got ' + (typeof floatValue);\n        }\n    } else {\n        throw 'The $difference function first argument must be a number, integer, float, or scalar type; got ' + (typeof arg1);\n    }\n    \n    // Process second argument\n    let value2 = 0;\n    if (typeof arg2 === 'number') {\n        value2 = arg2;\n        if (!Number.isInteger(arg2)) {\n            resultType = 'float';\n        }\n    } else if (arg2 !== null && typeof arg2 === 'object' && arg2.hasOwnProperty('$scalar')) {\n        // TOSCA scalar type with unit\n        let scalarValue = arg2.$scalar;\n        if (typeof scalarValue === 'number') {\n            value2 = scalarValue;\n            if (!Number.isInteger(scalarValue)) {\n                resultType = 'float';\n            }\n        } else {\n            throw 'The $difference function second argument scalar must have a numeric value; got ' + (typeof scalarValue);\n        }\n    } else if (arg2 !== null && typeof arg2 === 'object' && arg2.hasOwnProperty('$integer')) {\n        // TOSCA integer type\n        let intValue = arg2.$integer;\n        if (typeof intValue === 'number' && Number.isInteger(intValue)) {\n            value2 = intValue;\n        } else {\n            throw 'The $difference function second argument integer must be an integer; got ' + (typeof intValue);\n        }\n    } else if (arg2 !== null && typeof arg2 === 'object' && arg2.hasOwnProperty('$float')) {\n        // TOSCA float type\n        let floatValue = arg2.$float;\n        if (typeof floatValue === 'number') {\n            value2 = floatValue;\n            resultType = 'float';\n        } else {\n            throw 'The $difference function second argument float must be a number; got ' + (typeof floatValue);\n        }\n    } else {\n        throw 'The $difference function second argument must be a number, integer, float, or scalar type; got ' + (typeof arg2);\n    }\n    \n    // Calculate difference: value1 - value2\n    let result = value1 - value2;\n    \n    // Return result as appropriate type\n    if (resultType === 'float') {\n        return parseFloat(result);\n    } else {\n        return parseInt(result);\n    }\n};"
          floor: "// [TOSCA-v2.0] @ 10.2.5.7\n\nexports.evaluate = function() {\n    if (arguments.length !== 1) {\n        throw 'The $floor function expects exactly one argument.';\n    }\n    \n    let arg = arguments[0];\n    \n    // Process the argument - must be float or number\n    let floatValue = 0;\n    \n    // Case 1: JavaScript number\n    if (typeof arg === 'number') {\n        floatValue = arg;\n    }\n    // Case 2: TOSCA float object\n    else if (arg !== null && typeof arg === 'object' && arg.hasOwnProperty('$float')) {\n        let value = arg.$float;\n        if (typeof value === 'number') {\n            floatValue = value;\n        } else {\n            throw 'The $floor function float argument must be a number; got ' + (typeof value);\n        }\n    }\n    // Case 3: TOSCA integer object (can be converted to float)\n    else if (arg !== null && typeof arg === 'object' && arg.hasOwnProperty('$integer')) {\n        let intValue = arg.$integer;\n        if (typeof intValue === 'number' && Number.isInteger(intValue)) {\n            floatValue = parseFloat(intValue);\n        } else {\n            throw 'The $floor function integer argument must be an integer; got ' + (typeof intValue);\n        }\n    }\n    // Case 4: Puccini's scalar representation with numeric value\n    else if (arg !== null && typeof arg === 'object' && arg.hasOwnProperty('scalar') && typeof arg.scalar === 'number') {\n        floatValue = arg.scalar;\n    }\n    // Case 5: Puccini's alternate format with $number\n    else if (arg !== null && typeof arg === 'object' && arg.hasOwnProperty('$number') && typeof arg.$number === 'number') {\n        floatValue = arg.$number;\n    }\n    else {\n        throw 'The $floor function argument must be a float or number type; got ' + (typeof arg);\n    }\n    \n    // Apply floor function and normalize -0 to 0\n    let result = Math.floor(floatValue);\n    return result === 0 ? 0 : result;  // Converte -0 in 0\n};"
          get_artifact: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 4.8.1
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 4.8.1
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 4.8.1
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 4.8.1

            const tosca = require('tosca.lib.utils');

            exports.evaluate = function(entity, artifactName, location, remove) {
              if (arguments.length < 2)
                throw 'must have at least 2 arguments';
              let nodeTemplate = tosca.getModelableEntity.call(this, entity).properties;
              if (!nodeTemplate.artifacts || !(artifactName in nodeTemplate.artifacts))
                throw util.sprintf('artifact %q not found in %q', artifactName, nodeTemplate.name);
              let artifact = nodeTemplate.artifacts[artifactName];
              if (artifact.$artifact === undefined)
                return artifact.sourcePath;
              return artifact.$artifact;
            };
          get_attribute: "// [TOSCA-Simple-Profile-YAML-v1.3] @ 4.5.1\n// [TOSCA-Simple-Profile-YAML-v1.2] @ 4.5.1\n// [TOSCA-Simple-Profile-YAML-v1.1] @ 4.5.1\n// [TOSCA-Simple-Profile-YAML-v1.0] @ 4.5.1\n\nconst tosca = require('tosca.lib.utils');\n\nexports.evaluate = function(entity, first) {\n    // Validate relationship attributes during evaluation\n    const args = Array.prototype.slice.call(arguments);\n    \n    if (args.length >= 4) {\n        // This looks like a relationship attribute access: [node, requirement, attribute, index]\n        const vertex = tosca.getModelableEntity.call(this, args[0]);\n        const requirementName = args[1];\n        const attributeName = args[2];\n        const relationshipIndex = args[3] || 0;\n        \n        // Validate that the relationship and attribute exist, and index is valid\n        tosca.validateRelationshipAttributeAccess(vertex, requirementName, attributeName, relationshipIndex);\n    }\n    \n    return tosca.getNestedValue.call(this, 'attribute', 'attributes', arguments);\n};"
          get_input: "// [TOSCA-Simple-Profile-YAML-v1.3] @ 4.4.1\n// [TOSCA-Simple-Profile-YAML-v1.2] @ 4.4.1\n// [TOSCA-Simple-Profile-YAML-v1.1] @ 4.4.1\n// [TOSCA-Simple-Profile-YAML-v1.0] @ 4.4.1\n\nconst tosca = require('tosca.lib.utils');\n\nexports.evaluate = function() {\n    if (arguments.length < 1 || arguments.length > 2)\n        throw 'must have 1 or 2 arguments';\n    if (!tosca.isTosca(clout))\n        throw 'Clout is not TOSCA';\n    \n    let input, nestedPath;\n    \n    // Handle both syntaxes:\n    // $get_input: input_name\n    // $get_input: [input_name, index/key, ...]\n    if (arguments.length === 1) {\n        if (Array.isArray(arguments[0])) {\n            // Syntax: $get_input: [input_name, nested_elements...]\n            input = arguments[0][0];\n            nestedPath = arguments[0].slice(1);\n        } else {\n            // Syntax: $get_input: input_name\n            input = arguments[0];\n            nestedPath = null;\n        }\n    } else {\n        // Alternative syntax with separate arguments (for compatibility)\n        input = arguments[0];\n        nestedPath = [arguments[1]];\n    }\n    \n    let inputs = clout.properties.tosca.inputs;\n    if (!(input in inputs))\n        throw util.sprintf('input %q not found', input);\n    let r = inputs[input];\n    r = clout.coerce(r);\n    \n    // Navigate through the structure if a path is specified\n    if (nestedPath && nestedPath.length > 0) {\n        for (let i = 0; i < nestedPath.length; i++) {\n            let key = nestedPath[i];\n            if (Array.isArray(r)) {\n                // Array index access\n                let index = parseInt(key);\n                if (isNaN(index) || index < 0 || index >= r.length) {\n                    throw util.sprintf('index %d out of bounds for input %q (length %d)', index, input, r.length);\n                }\n                r = r[index];\n            } else if (r && typeof r === 'object') {\n                // Object property access\n                if (!(key in r)) {\n                    throw util.sprintf('property %q not found in input %q', key, input);\n                }\n                r = r[key];\n            } else {\n                throw util.sprintf('cannot access %q in non-object/non-array value', key);\n            }\n        }\n    }\n    \n    return r;\n};"
          get_nodes_of_type: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 4.7.1
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 4.7.1
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 4.7.1
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 4.7.1

            const tosca = require('tosca.lib.utils');

            exports.evaluate = function(typeName) {
              if (arguments.length !== 1)
                throw 'must have 1 argument';
              let names = [];
              for (let id in clout.vertexes) {
                let vertex = clout.vertexes[id];
                if (tosca.isTosca(vertex))
                  names.push(vertex.properties.name);
              }
              return names;
            };
          get_operation_output: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 4.6.1
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 4.6.1
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 4.6.1
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 4.6.1

            exports.evaluate = function() {
              return 'TODO';
            };
          get_property: |-
            // [TOSCA-Simple-Profile-YAML-v2.0] @ 10.2.1.2
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 4.4.2
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 4.4.2
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 4.4.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 4.4.2

            const tosca = require('tosca.lib.utils');

            exports.evaluate = function() {
                return tosca.getNestedValue.call(this, 'property', 'properties', arguments);
            };
          intersection: "// [TOSCA-v2.0] @ 10.2.4.2\n\nexports.evaluate = function() {\n    if (arguments.length === 0) {\n        throw 'The $intersection function expects at least one argument.';\n    }\n    \n    // Validate that all arguments are lists/arrays\n    for (let i = 0; i < arguments.length; i++) {\n        if (!Array.isArray(arguments[i])) {\n            throw 'The $intersection function argument ' + i + ' must be a list; got ' + (typeof arguments[i]);\n        }\n    }\n    \n    // Special case: only one list - remove duplicates (same as union for single list)\n    if (arguments.length === 1) {\n        let result = [];\n        let seen = new Set();\n        \n        for (let j = 0; j < arguments[0].length; j++) {\n            let element = arguments[0][j];\n            let key = JSON.stringify(element);\n            \n            if (!seen.has(key)) {\n                seen.add(key);\n                result.push(element);\n            }\n        }\n        \n        return result;\n    }\n    \n    // Multiple lists: find intersection\n    let result = [];\n    let firstList = arguments[0];\n    \n    // For each element in the first list\n    for (let i = 0; i < firstList.length; i++) {\n        let element = firstList[i];\n        let elementKey = JSON.stringify(element);\n        let foundInAll = true;\n        \n        // Check if this element exists in all other lists\n        for (let listIndex = 1; listIndex < arguments.length; listIndex++) {\n            let currentList = arguments[listIndex];\n            let foundInCurrentList = false;\n            \n            for (let j = 0; j < currentList.length; j++) {\n                if (JSON.stringify(currentList[j]) === elementKey) {\n                    foundInCurrentList = true;\n                    break;\n                }\n            }\n            \n            if (!foundInCurrentList) {\n                foundInAll = false;\n                break;\n            }\n        }\n        \n        // If element is found in all lists and not already in result\n        if (foundInAll) {\n            let alreadyInResult = false;\n            for (let k = 0; k < result.length; k++) {\n                if (JSON.stringify(result[k]) === elementKey) {\n                    alreadyInResult = true;\n                    break;\n                }\n            }\n            \n            if (!alreadyInResult) {\n                result.push(element);\n            }\n        }\n    }\n    \n    return result;\n};"
          join: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 4.3.2

            exports.evaluate = function() {
              let length = arguments.length;
              if ((length < 1) || (length > 2))
                throw 'must have 1 or 2 arguments';
              let delimiter = (length == 2) ? arguments[1] : '';
              let args = arguments[0];
              length = args.length;
              let a = [];
              for (let i = 0; i < length; i++) {
                let argument = args[i];
                if (argument.$string !== undefined)
                  argument = argument.$string;
                a.push(argument);
              }
              return a.join(delimiter);
            };
          length: "// TOSCA $length function\n// [TOSCA-v2.0] @ 10.2.3.1\n\nexports.evaluate = function(arg) {\n    if (arguments.length !== 1) {\n        throw 'The $length function expects exactly one argument.';\n    }\n\n    if (arg === null || arg === undefined) {\n        throw 'The $length function argument cannot be null or undefined.';\n    }\n\n    if (typeof arg === 'string') {\n        return arg.length;\n    }\n\n    if (Array.isArray(arg)) {\n        return arg.length;\n    }\n\n    // In Goja, ard.Map becomes a JS object\n    if (typeof arg === 'object' && arg !== null && !Array.isArray(arg)) {\n        return Object.keys(arg).length;\n    }\n    \n    throw 'The $length function argument must be a string, list, or map; got ' + (typeof arg);\n};"
          product: "// [TOSCA-v2.0] @ 10.2.5.3\n\nexports.evaluate = function() {\n    if (arguments.length === 0) {\n        throw 'The $product function expects at least one argument.';\n    }\n    \n    // Case 1: Two arguments - check for scalar multiplication\n    if (arguments.length === 2) {\n        let arg1 = arguments[0];\n        let arg2 = arguments[1];\n        \n        // Check if first argument is a scalar string (like \"512 MiB\")\n        if (typeof arg1 === 'string') {\n            // Parse scalar string format: \"value unit\"\n            let parts = arg1.trim().split(/\\s+/);\n            if (parts.length >= 2) {\n                let scalarValue = parseFloat(parts[0]);\n                let unit = parts.slice(1).join(' ');\n                \n                if (!isNaN(scalarValue)) {\n                    // Process second argument (multiplier)\n                    let multiplier = 0;\n                    if (typeof arg2 === 'number') {\n                        multiplier = arg2;\n                    } else if (arg2 !== null && typeof arg2 === 'object' && arg2.hasOwnProperty('$integer')) {\n                        let intValue = arg2.$integer;\n                        if (typeof intValue === 'number' && Number.isInteger(intValue)) {\n                            multiplier = intValue;\n                        } else {\n                            throw 'The $product function integer argument must be an integer; got ' + (typeof intValue);\n                        }\n                    } else if (arg2 !== null && typeof arg2 === 'object' && arg2.hasOwnProperty('$float')) {\n                        let floatValue = arg2.$float;\n                        if (typeof floatValue === 'number') {\n                            multiplier = floatValue;\n                        } else {\n                            throw 'The $product function float argument must be a number; got ' + (typeof floatValue);\n                        }\n                    } else {\n                        throw 'The $product function second argument must be a number, integer, or float type; got ' + (typeof arg2);\n                    }\n                    \n                    // Return scalar string with multiplied value\n                    let resultValue = scalarValue * multiplier;\n                    return resultValue + ' ' + unit;\n                }\n            }\n        }\n        \n        // Check if first argument is a TOSCA scalar object\n        if (arg1 !== null && typeof arg1 === 'object' && arg1.hasOwnProperty('$scalar')) {\n            let scalarValue = arg1.$scalar;\n            let multiplier = 0;\n            \n            // Validate scalar value\n            if (typeof scalarValue !== 'number') {\n                throw 'The $product function scalar argument must have a numeric value; got ' + (typeof scalarValue);\n            }\n            \n            // Process second argument (multiplier)\n            if (typeof arg2 === 'number') {\n                multiplier = arg2;\n            } else if (arg2 !== null && typeof arg2 === 'object' && arg2.hasOwnProperty('$integer')) {\n                let intValue = arg2.$integer;\n                if (typeof intValue === 'number' && Number.isInteger(intValue)) {\n                    multiplier = intValue;\n                } else {\n                    throw 'The $product function integer argument must be an integer; got ' + (typeof intValue);\n                }\n            } else if (arg2 !== null && typeof arg2 === 'object' && arg2.hasOwnProperty('$float')) {\n                let floatValue = arg2.$float;\n                if (typeof floatValue === 'number') {\n                    multiplier = floatValue;\n                } else {\n                    throw 'The $product function float argument must be a number; got ' + (typeof floatValue);\n                }\n            } else {\n                throw 'The $product function second argument must be a number, integer, or float type; got ' + (typeof arg2);\n            }\n            \n            // Return scalar with multiplied value\n            return {\n                $scalar: scalarValue * multiplier,\n                unit: arg1.unit // Preserve unit if present\n            };\n        }\n    }\n    \n    // Case 2: Multiple arguments - numeric multiplication\n    let result = 1;\n    let resultType = 'integer'; // Start with integer, upgrade to float if needed\n    \n    // Process each argument\n    for (let i = 0; i < arguments.length; i++) {\n        let arg = arguments[i];\n        \n        // Validate argument type\n        if (typeof arg === 'number') {\n            // JavaScript number (can be integer or float)\n            result *= arg;\n            \n            // If any argument is a float, result becomes float\n            if (!Number.isInteger(arg)) {\n                resultType = 'float';\n            }\n        } else if (arg !== null && typeof arg === 'object' && arg.hasOwnProperty('$integer')) {\n            // TOSCA integer type\n            let intValue = arg.$integer;\n            if (typeof intValue === 'number' && Number.isInteger(intValue)) {\n                result *= intValue;\n            } else {\n                throw 'The $product function integer argument ' + i + ' must be an integer; got ' + (typeof intValue);\n            }\n        } else if (arg !== null && typeof arg === 'object' && arg.hasOwnProperty('$float')) {\n            // TOSCA float type\n            let floatValue = arg.$float;\n            if (typeof floatValue === 'number') {\n                result *= floatValue;\n                resultType = 'float';\n            } else {\n                throw 'The $product function float argument ' + i + ' must be a number; got ' + (typeof floatValue);\n            }\n        } else {\n            throw 'The $product function argument ' + i + ' must be a number, integer, or float type; got ' + (typeof arg);\n        }\n    }\n    \n    // Return result as appropriate type\n    if (resultType === 'float') {\n        return parseFloat(result);\n    } else {\n        return parseInt(result);\n    }\n};"
          quotient: "// [TOSCA-v2.0] @ 10.2.5.4\n\nexports.evaluate = function() {\n    if (arguments.length !== 2) {\n        throw 'The $quotient function expects exactly two arguments.';\n    }\n    \n    let arg1 = arguments[0];\n    let arg2 = arguments[1];\n    \n    // Process second argument (divisor) first - must be number, integer, or float\n    let divisor = 0;\n    if (typeof arg2 === 'number') {\n        divisor = arg2;\n    } else if (arg2 !== null && typeof arg2 === 'object' && arg2.hasOwnProperty('$integer')) {\n        let intValue = arg2.$integer;\n        if (typeof intValue === 'number' && Number.isInteger(intValue)) {\n            divisor = intValue;\n        } else {\n            throw 'The $quotient function second argument integer must be an integer; got ' + (typeof intValue);\n        }\n    } else if (arg2 !== null && typeof arg2 === 'object' && arg2.hasOwnProperty('$float')) {\n        let floatValue = arg2.$float;\n        if (typeof floatValue === 'number') {\n            divisor = floatValue;\n        } else {\n            throw 'The $quotient function second argument float must be a number; got ' + (typeof floatValue);\n        }\n    } else {\n        throw 'The $quotient function second argument must be a number, integer, or float type; got ' + (typeof arg2);\n    }\n    \n    // Check for division by zero\n    if (divisor === 0) {\n        throw 'The $quotient function cannot divide by zero.';\n    }\n    \n    // Case 1: First argument is a scalar string (like \"1024 MiB\")\n    if (typeof arg1 === 'string') {\n        // Parse scalar string format: \"value unit\"\n        let parts = arg1.trim().split(/\\s+/);\n        if (parts.length >= 2) {\n            let scalarValue = parseFloat(parts[0]);\n            let unit = parts.slice(1).join(' ');\n            \n            if (!isNaN(scalarValue)) {\n                // Return scalar string with divided value (truncated if necessary)\n                let resultValue = scalarValue / divisor;\n                // Truncate towards zero (implementation decision)\n                resultValue = Math.trunc(resultValue);\n                return resultValue + ' ' + unit;\n            }\n        }\n        \n        throw 'The $quotient function first argument scalar string is malformed: ' + arg1;\n    }\n    \n    // Case 2: First argument is a TOSCA scalar object\n    if (arg1 !== null && typeof arg1 === 'object' && arg1.hasOwnProperty('$scalar')) {\n        let scalarValue = arg1.$scalar;\n        \n        // Validate scalar value\n        if (typeof scalarValue !== 'number') {\n            throw 'The $quotient function scalar argument must have a numeric value; got ' + (typeof scalarValue);\n        }\n        \n        // Return scalar with divided value (truncated if necessary)\n        let resultValue = scalarValue / divisor;\n        // Truncate towards zero (implementation decision)\n        resultValue = Math.trunc(resultValue);\n        \n        return {\n            $scalar: resultValue,\n            unit: arg1.unit // Preserve unit if present\n        };\n    }\n    \n    // Case 3: First argument is a number (integer or float)\n    let dividend = 0;\n    if (typeof arg1 === 'number') {\n        dividend = arg1;\n    } else if (arg1 !== null && typeof arg1 === 'object' && arg1.hasOwnProperty('$integer')) {\n        // TOSCA integer type\n        let intValue = arg1.$integer;\n        if (typeof intValue === 'number' && Number.isInteger(intValue)) {\n            dividend = intValue;\n        } else {\n            throw 'The $quotient function first argument integer must be an integer; got ' + (typeof intValue);\n        }\n    } else if (arg1 !== null && typeof arg1 === 'object' && arg1.hasOwnProperty('$float')) {\n        // TOSCA float type\n        let floatValue = arg1.$float;\n        if (typeof floatValue === 'number') {\n            dividend = floatValue;\n        } else {\n            throw 'The $quotient function first argument float must be a number; got ' + (typeof floatValue);\n        }\n    } else {\n        throw 'The $quotient function first argument must be a number, integer, float, or scalar type; got ' + (typeof arg1);\n    }\n    \n    // Calculate quotient - always returns float for numeric division\n    let result = dividend / divisor;\n    return parseFloat(result);\n};"
          remainder: "// [TOSCA-v2.0] @ 10.2.5.5\n\nexports.evaluate = function() {\n    if (arguments.length !== 2) {\n        throw 'The $remainder function expects exactly two arguments.';\n    }\n    \n    let arg1 = arguments[0];\n    let arg2 = arguments[1];\n    \n    // Process second argument (divisor) - must be integer\n    let divisor = 0;\n    if (typeof arg2 === 'number' && Number.isInteger(arg2)) {\n        divisor = arg2;\n    } else if (arg2 !== null && typeof arg2 === 'object' && arg2.hasOwnProperty('$integer')) {\n        let intValue = arg2.$integer;\n        if (typeof intValue === 'number' && Number.isInteger(intValue)) {\n            divisor = intValue;\n        } else {\n            throw 'The $remainder function second argument integer must be an integer; got ' + (typeof intValue);\n        }\n    } else {\n        throw 'The $remainder function second argument must be an integer; got ' + (typeof arg2);\n    }\n    \n    // Check for division by zero\n    if (divisor === 0) {\n        throw 'The $remainder function cannot divide by zero.';\n    }\n    \n    // Process first argument\n    let dividend = 0;\n    let unit = '';\n    let isScalar = false;\n    \n    // Case 1: Scalar string (like \"90 s\")\n    if (typeof arg1 === 'string') {\n        // Parse scalar string format: \"value unit\"\n        let parts = arg1.trim().split(/\\s+/);\n        if (parts.length >= 2) {\n            let scalarValue = parseFloat(parts[0]);\n            unit = parts.slice(1).join(' ');\n            \n            if (!isNaN(scalarValue)) {\n                dividend = Math.floor(scalarValue); // Ensure integer for remainder\n                isScalar = true;\n            } else {\n                throw 'The $remainder function first argument scalar must have a numeric value; got ' + parts[0];\n            }\n        } else {\n            throw 'The $remainder function first argument scalar string is malformed: ' + arg1;\n        }\n    }\n    // Case 2: Puccini's complex scalar object format\n    else if (arg1 !== null && typeof arg1 === 'object') {\n        // Handle Puccini's scalar representation\n        if (arg1.hasOwnProperty('scalar') && typeof arg1.scalar === 'number') {\n            dividend = Math.floor(arg1.scalar);\n            unit = arg1.unit || '';\n            isScalar = true;\n        } else if (arg1.hasOwnProperty('$number') && typeof arg1.$number === 'number') {\n            dividend = Math.floor(arg1.$number);\n            unit = arg1.unit || '';\n            isScalar = true;\n        } else if (arg1.hasOwnProperty('$scalar')) {\n            let scalarValue = arg1.$scalar;\n            if (typeof scalarValue === 'number') {\n                dividend = Math.floor(scalarValue);\n                unit = arg1.unit || '';\n                isScalar = true;\n            } else {\n                throw 'The $remainder function scalar argument must have a numeric value; got ' + (typeof scalarValue);\n            }\n        } else if (arg1.hasOwnProperty('$integer')) {\n            let intValue = arg1.$integer;\n            if (typeof intValue === 'number' && Number.isInteger(intValue)) {\n                dividend = intValue;\n            } else {\n                throw 'The $remainder function first argument integer must be an integer; got ' + (typeof intValue);\n            }\n        } else {\n            throw 'The $remainder function first argument format not recognized: ' + JSON.stringify(arg1);\n        }\n    }\n    // Case 3: Plain integer\n    else if (typeof arg1 === 'number' && Number.isInteger(arg1)) {\n        dividend = arg1;\n    }\n    else {\n        throw 'The $remainder function first argument must be an integer or scalar type; got ' + (typeof arg1);\n    }\n    \n    // Calculate remainder\n    let result = dividend % divisor;\n    \n    // Return appropriate format\n    if (isScalar && unit) {\n        // Return as scalar string to match TOSCA format\n        return result + ' ' + unit;\n    } else {\n        return parseInt(result);\n    }\n};"
          round: "// [TOSCA-v2.0] @ 10.2.5.6\n\nexports.evaluate = function() {\n    if (arguments.length !== 1) {\n        throw 'The $round function expects exactly one argument.';\n    }\n    \n    let arg = arguments[0];\n    \n    // Process the argument - must be float or number\n    let floatValue = 0;\n    \n    // Case 1: JavaScript number\n    if (typeof arg === 'number') {\n        floatValue = arg;\n    }\n    // Case 2: TOSCA float object\n    else if (arg !== null && typeof arg === 'object' && arg.hasOwnProperty('$float')) {\n        let value = arg.$float;\n        if (typeof value === 'number') {\n            floatValue = value;\n        } else {\n            throw 'The $round function float argument must be a number; got ' + (typeof value);\n        }\n    }\n    // Case 3: TOSCA integer object (can be converted to float)\n    else if (arg !== null && typeof arg === 'object' && arg.hasOwnProperty('$integer')) {\n        let intValue = arg.$integer;\n        if (typeof intValue === 'number' && Number.isInteger(intValue)) {\n            floatValue = parseFloat(intValue);\n        } else {\n            throw 'The $round function integer argument must be an integer; got ' + (typeof intValue);\n        }\n    }\n    // Case 4: Puccini's scalar representation with numeric value\n    else if (arg !== null && typeof arg === 'object' && arg.hasOwnProperty('scalar') && typeof arg.scalar === 'number') {\n        floatValue = arg.scalar;\n    }\n    // Case 5: Puccini's alternate format with $number\n    else if (arg !== null && typeof arg === 'object' && arg.hasOwnProperty('$number') && typeof arg.$number === 'number') {\n        floatValue = arg.$number;\n    }\n    else {\n        throw 'The $round function argument must be a float or number type; got ' + (typeof arg);\n    }\n    \n    // Implement TOSCA rounding rule:\n    // Equal value distance is rounded down (e.g. 3.5 -> 3, 3.53 -> 4)\n    // This means: if fractional part is exactly 0.5, round down; otherwise use normal rounding\n    \n    let fractionalPart = Math.abs(floatValue - Math.trunc(floatValue));\n    \n    // Calculate result and normalize -0 to 0\n    let result;\n    if (Math.abs(fractionalPart - 0.5) < Number.EPSILON) {\n        result = Math.trunc(floatValue);\n    } else {\n        result = Math.round(floatValue);\n    }\n    return result === 0 ? 0 : result;  // Converte -0 in 0\n};"
          sum: "// [TOSCA-v2.0] @ 10.2.5.1\n\nexports.evaluate = function() {\n    if (arguments.length === 0) {\n        throw 'The $sum function expects at least one argument.';\n    }\n    \n    let result = 0;\n    let resultType = 'integer'; // Start with integer, upgrade to float if needed\n    \n    // Process each argument\n    for (let i = 0; i < arguments.length; i++) {\n        let arg = arguments[i];\n        \n        // Validate argument type\n        if (typeof arg === 'number') {\n            // JavaScript number (can be integer or float)\n            result += arg;\n            \n            // If any argument is a float, result becomes float\n            if (!Number.isInteger(arg)) {\n                resultType = 'float';\n            }\n        } else if (arg !== null && typeof arg === 'object' && arg.hasOwnProperty('$scalar')) {\n            // TOSCA scalar type with unit\n            let scalarValue = arg.$scalar;\n            if (typeof scalarValue === 'number') {\n                result += scalarValue;\n                \n                if (!Number.isInteger(scalarValue)) {\n                    resultType = 'float';\n                }\n            } else {\n                throw 'The $sum function scalar argument ' + i + ' must have a numeric value; got ' + (typeof scalarValue);\n            }\n        } else if (arg !== null && typeof arg === 'object' && arg.hasOwnProperty('$integer')) {\n            // TOSCA integer type\n            let intValue = arg.$integer;\n            if (typeof intValue === 'number' && Number.isInteger(intValue)) {\n                result += intValue;\n            } else {\n                throw 'The $sum function integer argument ' + i + ' must be an integer; got ' + (typeof intValue);\n            }\n        } else if (arg !== null && typeof arg === 'object' && arg.hasOwnProperty('$float')) {\n            // TOSCA float type\n            let floatValue = arg.$float;\n            if (typeof floatValue === 'number') {\n                result += floatValue;\n                resultType = 'float';\n            } else {\n                throw 'The $sum function float argument ' + i + ' must be a number; got ' + (typeof floatValue);\n            }\n        } else {\n            throw 'The $sum function argument ' + i + ' must be a number, integer, float, or scalar type; got ' + (typeof arg);\n        }\n    }\n    \n    // Return result as appropriate type\n    if (resultType === 'float') {\n        return parseFloat(result);\n    } else {\n        return parseInt(result);\n    }\n};"
          token: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 4.3.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 4.3.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 4.3.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 4.3.2

            exports.evaluate = function(v, separators, index) {
              if (arguments.length !== 3)
                throw 'must have 3 arguments';
              if (v.$string !== undefined)
                v = v.$string;
              let s = v.split(new RegExp('[' + escape(separators) + ']'));
              return s[index];
            };

            function escape(s) {
              return s.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
            }
          union: "// [TOSCA-v2.0] @ 10.2.4.1\n\nexports.evaluate = function() {\n    if (arguments.length === 0) {\n        throw 'The $union function expects at least one argument.';\n    }\n    \n    let result = [];\n    let seen = new Set();\n    \n    // Process each list argument\n    for (let i = 0; i < arguments.length; i++) {\n        let arg = arguments[i];\n        \n        // Validate that the argument is a list/array\n        if (!Array.isArray(arg)) {\n            throw 'The $union function argument ' + i + ' must be a list; got ' + (typeof arg);\n        }\n        \n        // Add unique elements to result\n        for (let j = 0; j < arg.length; j++) {\n            let element = arg[j];\n            \n            // Create a string key for comparison (handles objects and primitives)\n            let key = JSON.stringify(element);\n            \n            if (!seen.has(key)) {\n                seen.add(key);\n                result.push(element);\n            }\n        }\n    }\n    \n    return result;\n};"
        lib:
          traversal: |-
            const tosca = require('tosca.lib.utils');

            exports.toCoercibles = function(clout_) {
              if (!clout_)
                clout_ = clout;
              exports.traverseValues(clout_, function(data) {
                return clout_.newCoercible(data.value, data.site, data.source, data.target);
              });
            };

            exports.unwrapCoercibles = function(clout_) {
              if (!clout_)
                clout_ = clout;
              exports.traverseValues(clout_, function(data) {
                return clout_.unwrap(data.value);
              });
            };

            exports.coerce = function(clout_) {
              if (!clout_)
                clout_ = clout;
              exports.toCoercibles(clout_);
              exports.traverseValues(clout_, function(data) {
                return clout_.coerce(data.value);
              });
            };

            exports.getValueType = function(clout_) {
              if (!clout_)
                clout_ = clout;
              let valueType = {};
              exports.traverseValues(clout_, function(data) {
                if (data.value.$meta)
                  valueType[data.path.join('.')] = data.value.$meta.type;
                return data.value;
              });
              return valueType;
            };

            exports.hasQuirk = function(clout_, quirk) {
              if (!clout_)
                clout_ = clout;
              let quirks = clout_.properties.tosca.metadata['puccini.quirks'];
              if (quirks !== undefined) {
                quirks = quirks.split(',');
                for (let q = 0, l = quirks.length; q < l; q++)
                  if (quirks[q] === quirk)
                    return true;
              }
              return false;
            };

            exports.traverseValues = function(clout_, traverser) {
              if (!clout_)
                clout_ = clout;

              if (tosca.isTosca(clout_)) {
                exports.traverseObjectValues(traverser, ['inputs'], clout_.properties.tosca.inputs);
                exports.traverseObjectValues(traverser, ['outputs'], clout_.properties.tosca.outputs);
              }

              for (let vertexId in clout_.vertexes) {
                let vertex = clout_.vertexes[vertexId];
                if (!tosca.isTosca(vertex))
                  continue;

                if (tosca.isNodeTemplate(vertex)) {
                  let nodeTemplate = vertex.properties;
                  let path = ['nodeTemplates', nodeTemplate.name];

                  exports.traverseObjectValues(traverser, copyAndPush(path, 'properties'), nodeTemplate.properties, vertex);
                  exports.traverseObjectValues(traverser, copyAndPush(path, 'attributes'), nodeTemplate.attributes, vertex);
                  exports.traverseInterfaceValues(traverser, copyAndPush(path, 'interfaces'), nodeTemplate.interfaces, vertex)

                  for (let capabilityName in nodeTemplate.capabilities) {
                    let capability = nodeTemplate.capabilities[capabilityName];
                    let capabilityPath = copyAndPush(path, 'capabilities', capabilityName);
                    exports.traverseObjectValues(traverser, copyAndPush(capabilityPath, 'properties'), capability.properties, vertex);
                    exports.traverseObjectValues(traverser, copyAndPush(capabilityPath, 'attributes'), capability.attributes, vertex);
                  }

                  for (let artifactName in nodeTemplate.artifacts) {
                    let artifact = nodeTemplate.artifacts[artifactName];
                    let artifactPath = copyAndPush(path, 'artifacts', artifactName);
                    exports.traverseObjectValues(traverser, copyAndPush(artifactPath, 'properties'), artifact.properties, vertex);
                    if (artifact.credential !== null)
                      try {
                        artifact.credential = traverser({
                          path: copyAndPush(artifactPath, 'credential'),
                          value: artifact.credential,
                          site: vertex
                        });
                      } catch (x) {
                        if ((typeof problems !== 'undefined') && x.value && x.value.error)
                          // Unwrap Go error
                          problems.reportError(x.value);
                        else
                          throw x;
                      }
                  }

                  for (let e = 0, l = vertex.edgesOut.size(); e < l; e++) {
                    let edge = vertex.edgesOut[e];
                    if (!tosca.isTosca(edge, 'Relationship'))
                      continue;

                    let relationship = edge.properties;
                    let relationshipPath = copyAndPush(path, 'relationships', relationship.name);
                    exports.traverseObjectValues(traverser, copyAndPush(relationshipPath, 'properties'), relationship.properties, edge, vertex, edge.target);
                    exports.traverseObjectValues(traverser,copyAndPush(relationshipPath, 'attributes'), relationship.attributes, edge, vertex, edge.target);
                    exports.traverseInterfaceValues(traverser, copyAndPush(relationshipPath, 'interfaces'), relationship.interfaces, edge, vertex, edge.target);
                  }
                } else if (tosca.isTosca(vertex, 'Group')) {
                  let group = vertex.properties;
                  let path = ['groups', group.name];

                  exports.traverseObjectValues(traverser, copyAndPush(path, 'properties'), group.properties, vertex);
                  exports.traverseInterfaceValues(traverser, copyAndPush(path, 'attributes'), group.interfaces, vertex)
                } else if (tosca.isTosca(vertex, 'Policy')) {
                  let policy = vertex.properties;
                  let path = ['policies', policy.name];

                  exports.traverseObjectValues(traverser, copyAndPush(path, 'properties'), policy.properties, vertex);
                } else if (tosca.isTosca(vertex, 'Substitution')) {
                  let substitution = vertex.properties;
                  let path = ['substitution'];

                  exports.traverseObjectValues(traverser, copyAndPush(path, 'properties'), substitution.properties, vertex);
                }
              }
            };

            exports.traverseInterfaceValues = function(traverser, path, interfaces, site, source, target) {
              for (let interfaceName in interfaces) {
                let interface_ = interfaces[interfaceName];
                let interfacePath = copyAndPush(path, interfaceName)
                exports.traverseObjectValues(traverser, copyAndPush(interfacePath, 'inputs'), interface_.inputs, site, source, target);
                for (let operationName in interface_.operations) {
                  let operationPath = copyAndPush(interfacePath, 'operations', operationName);
                  exports.traverseObjectValues(traverser, operationPath, interface_.operations[operationName].inputs, site, source, target);
                  exports.traverseObjectValues(traverser, operationPath, interface_.operations[operationName].outputs, site, source, target);
                }
                for (let notificationName in interface_.notifications) {
                  let notificationPath = copyAndPush(interfacePath, 'notifications', notificationName);
                  exports.traverseObjectValues(traverser, notificationPath, interface_.notifications[notificationName].outputs, site, source, target);
                }
              }
            };

            exports.traverseObjectValues = function(traverser, path, object, site, source, target) {
              for (let key in object)
                try {
                  object[key] = traverser({
                    path: copyAndPush(path, key),
                    value: object[key],
                    site: site,
                    source: source,
                    target: target
                  });
                } catch (x) {
                  if ((typeof problems !== 'undefined') && x.value && x.value.error)
                    // Unwrap Go error
                    problems.reportError(x.value);
                  else
                    throw x;
                }
            };

            function copyAndPush(array) {
              let array_ = [];
              for (let i = 0, l = array.length; i < l; i++)
                array_.push(array[i]);
              for (let i = 1, l = arguments.length; i < l; i++)
                array_.push(arguments[i]);
              return array_;
            }
          utils: "exports.isTosca = function(o, kind) {\n  if (o.metadata === undefined)\n    return false;\n  o = o.metadata['puccini'];\n  if (o === undefined)\n    return false;\n  if (o.version !== '1.0')\n    return false;\n  if (kind !== undefined)\n    return kind === o.kind;\n  return true;\n};\n\nexports.isNodeTemplate = function(vertex, typeName) {\n  if (exports.isTosca(vertex, 'NodeTemplate')) {\n    if (typeName !== undefined)\n      return typeName in vertex.properties.types;\n    return true;\n  }\n  return false;\n};\n\nexports.setOutputValue = function(name, value) {\n  if (clout.properties.tosca === undefined)\n    return false;\n  let output = clout.properties.tosca.outputs[name];\n  if (output === undefined)\n    return false;\n\n  if (output.$type && output.$type.type)\n    switch (output.$type.type.name) {\n    case 'boolean':\n      value = (value === 'true');\n      break;\n    case 'integer':\n      value = parseInt(value);\n      break;\n    case 'float':\n      value = parseFloat(value);\n      break;\n    }\n\n  output.$value = value;\n  return true;\n};\n\nexports.getPolicyTargets = function(vertex) {\n  let targets = [];\n\n  function addTarget(target) {\n    for (let t = 0, l = targets.length; t < l; t++)\n      if (targets[t].name === target.name)\n        return;\n    targets.push(target);\n  }\n\n  for (let e = 0, l = vertex.edgesOut.size(); e < l; e++) {\n    let edge = vertex.edgesOut[e];\n    if (exports.isTosca(edge, 'NodeTemplateTarget'))\n      targets.push(clout.vertexes[edge.targetID].properties);\n    else if (toexportssca.isTosca(edge, 'GroupTarget')) {\n      let members = exports.getGroupMembers(clout.vertexes[edge.targetID]);\n      for (let m = 0, ll = members.length; m < ll; m++)\n        addTarget(members[m])\n    }\n  }\n  return targets;\n};\n\nexports.getGroupMembers = function(vertex) {\n  let members = [];\n  for (let e = 0, l = vertex.edgesOut.size(); e < l; e++) {\n    let edge = vertex.edgesOut[e];\n    if (exports.isTosca(edge, 'Member'))\n      members.push(clout.vertexes[edge.targetID].properties);\n  }\n  return members;\n};\n\nexports.addHistory = function(description) {\n  let metadata = clout.metadata;\n  if (metadata === undefined)\n    metadata = clout.metadata = {};\n  let history = metadata.history;\n  if (history === undefined)\n    history = [];\n  else\n    history = history.slice(0);\n  history.push({\n    timestamp: util.nowString(),\n    description: description\n  });\n  metadata.history = history;\n};\n\nexports.getNestedValue = function(singular, plural, args) {\n    args = Array.prototype.slice.call(args);\n    let length = args.length;\n    \n    if (length < 2)\n        throw 'must have at least 2 arguments';\n    \n    // Check if this looks like TOSCA 2.0 syntax (contains keywords)\n    let isTosca20 = false;\n    for (let i = 1; i < args.length; i++) {\n        if (typeof args[i] === 'string' && \n            ['RELATIONSHIP', 'TARGET', 'SOURCE', 'CAPABILITY'].includes(args[i])) {\n            isTosca20 = true;\n            break;\n        }\n    }\n    \n    // If not explicitly TOSCA 2.0, check if this could be a relationship access\n    if (!isTosca20 && length >= 3) {\n        let vertex = exports.getModelableEntity.call(this, args[0]);\n        let nodeTemplate = vertex.properties;\n        let relationshipName = args[1];\n        \n        // Check if args[1] is a relationship name rather than a capability or direct property/attribute\n        let isRelationship = false;\n        if (!(relationshipName in nodeTemplate.capabilities) && !(relationshipName in nodeTemplate[plural])) {\n            // Check if it's a relationship\n            for (let e = 0, l = vertex.edgesOut.size(); e < l; e++) {\n                let edge = vertex.edgesOut[e];\n                \n                if (exports.isTosca(edge, 'Relationship')) {\n                    let relationship = edge.properties;\n                    \n                    if (relationship.name === relationshipName) {\n                        isRelationship = true;\n                        break;\n                    }\n                }\n            }\n        }\n        \n        if (isRelationship) {\n            isTosca20 = true;\n        }\n    }\n    \n    if (isTosca20) {\n        return exports.getNestedValueTosca20.call(this, singular, plural, args);\n    }\n    \n    // Original implementation for backward compatibility\n    let vertex = exports.getModelableEntity.call(this, args[0]);\n    let nodeTemplate = vertex.properties;\n    let value = nodeTemplate[plural];\n    let a = 1;\n    let arg = args[a];\n    let nextArg = args[a+1];\n    let count = 0;\n    \n    if (arg in nodeTemplate.capabilities) {\n        value = nodeTemplate.capabilities[arg][plural];\n        singular = util.sprintf('capability %q %s', arg, singular);\n        arg = args[++a];\n    } else {\n        for (let e = 0, l = vertex.edgesOut.size(); e < l; e++) {\n            let edge = vertex.edgesOut[e];\n            if (!exports.isTosca(edge, 'Relationship'))\n                continue;\n            let relationship = edge.properties;\n            if (relationship.name === arg) {\n                if (count++ === nextArg) {\n                    value = relationship[plural];\n                    singular = util.sprintf('relationship %q %s', arg, singular);\n                    a += 2;\n                    arg = args[a];\n                    break;\n                }\n            }\n        }\n    }\n    \n    if ((typeof value === 'object') && (value !== null) && (arg in value))\n        value = value[arg];\n    else\n        throw util.sprintf('%s %q not found in %q', singular, arg, nodeTemplate.name);\n    \n    value = clout.coerce(value);\n    \n    for (let i = a + 1; i < length; i++) {\n        arg = args[i];\n        if ((typeof value === 'object') && (value !== null) && (arg in value))\n            value = value[arg];\n        else\n            throw util.sprintf('nested %s %q not found in %q', singular, args.slice(a, i+1).join('.'), nodeTemplate.name);\n    }\n    return value;\n};\n\n// TOSCA 2.0 path traversal following BNF grammar\nexports.getNestedValueTosca20 = function(singular, plural, args) {\n    args = Array.prototype.slice.call(args);\n    let length = args.length;\n    if (length < 2)\n        throw 'must have at least 2 arguments';\n    \n    let currentVertex = exports.getModelableEntity.call(this, args[0]);\n    let pathIndex = 1;\n    \n    // Parse according to BNF grammar: <tosca_path>\n    // <tosca_path> ::= <node_symbolic_name>, <idx>, <node_context> |\n    //                  SELF, <node_context> |\n    //                  SELF, <rel_context>\n    \n    while (pathIndex < args.length) {\n        let step = args[pathIndex];\n        \n        // Check if this is an explicit keyword\n        if (['RELATIONSHIP', 'TARGET', 'SOURCE', 'CAPABILITY'].includes(step)) {\n            switch (step) {\n                case 'RELATIONSHIP':\n                    // <node_context> ::= RELATIONSHIP, <requirement_name>, <idx>, <rel_context>\n                    pathIndex++;\n                    if (pathIndex >= args.length)\n                        throw 'RELATIONSHIP keyword must be followed by requirement name';\n                    \n                    let requirementName = args[pathIndex];\n                    pathIndex++;\n                    \n                    // Check for optional index\n                    let relationshipIndex = 0;\n                    if (pathIndex < args.length && typeof args[pathIndex] === 'number') {\n                        relationshipIndex = args[pathIndex];\n                        pathIndex++;\n                    }\n                    \n                    currentVertex = exports.traverseToRelationship(currentVertex, requirementName, relationshipIndex);\n                    break;\n                    \n                case 'TARGET':\n                    // <rel_context> ::= TARGET, <node_context>\n                    if (!exports.isTosca(currentVertex, 'Relationship'))\n                        throw 'TARGET can only be used in relationship context';\n                    \n                    currentVertex = currentVertex.target;\n                    pathIndex++;\n                    break;\n                    \n                case 'SOURCE':\n                    // <rel_context> ::= SOURCE, <node_context>\n                    if (!exports.isTosca(currentVertex, 'Relationship'))\n                        throw 'SOURCE can only be used in relationship context';\n                    \n                    currentVertex = currentVertex.source;\n                    pathIndex++;\n                    break;\n                    \n                case 'CAPABILITY':\n                    // <node_context> ::= CAPABILITY, <capability_name>, <cap_context>\n                    // <rel_context> ::= CAPABILITY, <cap_context>\n                    pathIndex++;\n                    if (pathIndex >= args.length)\n                        throw 'CAPABILITY keyword must be followed by capability name';\n                    \n                    if (exports.isTosca(currentVertex, 'Relationship')) {\n                        // In relationship context, CAPABILITY refers to the target capability\n                        // This is handled by the relationship's capability property\n                        pathIndex--; // Back up to handle capability access\n                        break;\n                    } else if (exports.isNodeTemplate(currentVertex)) {\n                        let capabilityName = args[pathIndex];\n                        pathIndex++;\n                        \n                        if (!(capabilityName in currentVertex.properties.capabilities))\n                            throw util.sprintf('capability %q not found in node %q', capabilityName, currentVertex.properties.name);\n                        \n                        // Switch to capability context for remaining path\n                        let capabilityTarget = currentVertex.properties.capabilities[capabilityName];\n                        return exports.getNestedPropertyValue(capabilityTarget, plural, args, pathIndex, singular);\n                    } else {\n                        throw 'CAPABILITY can only be used in node or relationship context';\n                    }\n                    break;\n            }\n        } else {\n            // Handle implicit syntax and property access\n            if (exports.isNodeTemplate(currentVertex)) {\n                let entityName = step;\n                \n                // First, check if it's a capability\n                if (entityName in currentVertex.properties.capabilities) {\n                    // This is a capability access\n                    let capabilityTarget = currentVertex.properties.capabilities[entityName];\n                    pathIndex++;\n                    return exports.getNestedPropertyValue(capabilityTarget, plural, args, pathIndex, singular);\n                } else {\n                    // Check if it's a requirement name (implicit relationship access)\n                    let requirementName = entityName;\n                    pathIndex++;\n                    \n                    // Check for optional index\n                    let relationshipIndex = 0;\n                    if (pathIndex < args.length && typeof args[pathIndex] === 'number') {\n                        relationshipIndex = args[pathIndex];\n                        pathIndex++;\n                    }\n                    \n                    // Try to find the relationship\n                    try {\n                        currentVertex = exports.traverseToRelationship(currentVertex, requirementName, relationshipIndex);\n                    } catch (e) {\n                        throw util.sprintf('neither capability nor relationship %q found in node %q', requirementName, currentVertex.properties.name);\n                    }\n                }\n            } else if (exports.isTosca(currentVertex, 'Relationship')) {\n                // We're in a relationship context, so remaining args are property access\n                return exports.getNestedPropertyValue(currentVertex.properties, plural, args, pathIndex, singular);\n            } else {\n                throw util.sprintf('unexpected token in TOSCA path: %s', step);\n            }\n        }\n    }\n    \n    // If we've consumed all arguments, we're accessing the entity itself\n    // This shouldn't happen for property/attribute access\n    throw 'invalid TOSCA path: no property specified';\n};\n\n// Helper function to get nested property values from an entity\nexports.getNestedPropertyValue = function(entity, plural, args, startIndex, singular) {\n    let value = entity[plural];\n    let entityName = entity.name || 'entity';\n    \n    // Coerce the initial value to handle Puccini's Value object structure\n    value = clout.coerce(value);\n    \n    for (let i = startIndex; i < args.length; i++) {\n        let arg = args[i];\n        \n        if ((typeof value === 'object') && (value !== null) && (arg in value)) {\n            value = value[arg];\n            // Coerce each intermediate value to handle nested Value objects\n            value = clout.coerce(value);\n        } else {\n            // Build a proper error message with the property path\n            let propertyPath = [];\n            for (let j = startIndex; j <= i; j++) {\n                propertyPath.push(args[j]);\n            }\n            throw util.sprintf('%s %q not found in %q (looking for path: %s)', \n                singular, arg, entityName, propertyPath.join('.'));\n        }\n    }\n    \n    return value;\n};\n\n// Helper function to traverse to a relationship by requirement name and index\nexports.traverseToRelationship = function(vertex, requirementName, relationshipIndex) {\n    if (!exports.isNodeTemplate(vertex)) {\n        throw util.sprintf('can only traverse relationships from node template context');\n    }\n    \n    let relationshipFound = false;\n    let relationshipCount = 0;\n    \n    for (let e = 0, l = vertex.edgesOut.size(); e < l; e++) {\n        let edge = vertex.edgesOut[e];\n        if (!exports.isTosca(edge, 'Relationship'))\n            continue;\n        \n        let relationship = edge.properties;\n        if (relationship.name === requirementName) {\n            if (relationshipCount === relationshipIndex) {\n                return edge; // Return relationship context\n            }\n            relationshipCount++;\n        }\n    }\n    \n    throw util.sprintf('relationship %q (index %d) not found in node %q', requirementName, relationshipIndex, vertex.properties.name);\n};\n\nexports.getModelableEntity = function(entity) {\n  let vertex;\n  switch (entity) {\n  case 'SELF':\n    if (!this || !this.site)\n      throw util.sprintf('%q cannot be used in this context', entity);\n    vertex = this.site;\n    break;\n  case 'SOURCE':\n    if (!this || !this.source)\n      throw util.sprintf('%q cannot be used in this context', entity);\n    vertex = this.source;\n    break;\n  case 'TARGET':\n    if (!this || !this.target)\n      throw util.sprintf('%q cannot be used in this context', entity);\n    vertex = this.target;\n    break;\n  case 'HOST':\n    if (!this || !this.site)\n      throw util.sprintf('%q cannot be used in this context', entity);\n    vertex = exports.getHost(this.site);\n    break;\n  default:\n    for (let vertexId in clout.vertexes) {\n      let vertex = clout.vertexes[vertexId];\n      if (exports.isNodeTemplate(vertex) && (vertex.properties.name === entity))\n        return vertex;\n    }\n    vertex = {};\n  }\n  if (exports.isNodeTemplate(vertex))\n    return vertex;\n  else\n    throw util.sprintf('%q node template not found', entity);\n};\n\nexports.getHost = function(vertex) {\n    for (let e = 0, l = vertex.edgesOut.size(); e < l; e++) {\n        let edge = vertex.edgesOut[e];\n        if (exports.isTosca(edge, 'Relationship')) {\n            for (let typeName in edge.properties.types) {\n                let type = edge.properties.types[typeName];\n                if (type && type.metadata && type.metadata.role === 'host') {\n                    return edge.target;\n                }\n            }\n        }\n    }\n    if (exports.isNodeTemplate(vertex))\n        throw util.sprintf('\"HOST\" not found for node template %q', vertex.properties.name);\n    else\n        throw '\"HOST\" not found';\n};\n\nexports.getComparable = function(v) {\n  if ((v === undefined) || (v === null))\n    return null;\n  let c = v.$number;\n  if (c !== undefined)\n    return c;\n  c = v.$string;\n  if (c !== undefined)\n    return c;\n  return v;\n};\n\nexports.getLength = function(v) {\n  if (v.$string !== undefined)\n    v = v.$string;\n  let length = v.length;\n  if (length === undefined)\n    length = Object.keys(v).length;\n  return length;\n};\n\nexports.compare = function(v1, v2) {\n  let c = v1.$comparer;\n  if (c === undefined)\n    c = v2.$comparer;\n  if (c !== undefined)\n    return clout.call(c, 'compare', [v1, v2]);\n  v1 = exports.getComparable(v1);\n  v2 = exports.getComparable(v2);\n  if (v1 == v2)\n    return 0;\n  else if (v1 < v2)\n    return -1;\n  else\n    return 1;\n};\n\n// See: https://stackoverflow.com/a/45683145\nexports.deepEqual = function(v1, v2) {\n  if (v1 === v2)\n    return true;\n\n  if (exports.isPrimitive(v1) && exports.isPrimitive(v2))\n    return v1 === v2;\n\n  if (Object.keys(v1).length !== Object.keys(v2).length)\n    return false;\n\n  for (let key in v1) {\n    if (!(key in v2)) return false;\n    if (!exports.deepEqual(v1[key], v2[key])) return false;\n  }\n\n  return true;\n};\n\nexports.isPrimitive = function(obj) {\n    return obj !== Object(obj);\n};\n\n// Parse scalar value using context from another scalar object\nexports.tryParseScalar = function(valueString, scalarObject) {\n    if (typeof valueString !== 'string' || !scalarObject) {\n        return null;\n    }\n\n    // Read scalar type information from various possible sources\n    const units = scalarObject.units || \n                  scalarObject.Units || \n                  (scalarObject.scalarType && scalarObject.scalarType.Units) ||\n                  (scalarObject.$scalarTypeInfo && scalarObject.$scalarTypeInfo.units);\n    \n    const canonicalUnit = scalarObject.canonicalUnit || \n                         scalarObject.CanonicalUnit ||\n                         (scalarObject.scalarType && scalarObject.scalarType.CanonicalUnit) ||\n                         (scalarObject.$scalarTypeInfo && scalarObject.$scalarTypeInfo.canonicalUnit);\n    \n    const baseType = scalarObject.baseType || \n                    scalarObject.BaseType || \n                    scalarObject.dataType ||\n                    (scalarObject.scalarType && scalarObject.scalarType.DataTypeName) ||\n                    (scalarObject.$scalarTypeInfo && scalarObject.$scalarTypeInfo.baseType);\n\n    const dataTypeName = scalarObject.dataTypeName || \n                        scalarObject.DataTypeName || \n                        (scalarObject.scalarType && scalarObject.scalarType.Name) ||\n                        (scalarObject.$scalarTypeInfo && scalarObject.$scalarTypeInfo.name) || \n                        '';\n\n    const prefixes = scalarObject.prefixes ||\n                    scalarObject.Prefixes ||\n                    (scalarObject.scalarType && scalarObject.scalarType.Prefixes) ||\n                    (scalarObject.$scalarTypeInfo && scalarObject.$scalarTypeInfo.prefixes);\n\n    // Verify that we have all necessary information\n    if (!units || !canonicalUnit || !baseType) {\n        return null;\n    }\n\n    // Parse the scalar value string - handle both with and without spaces (TOSCA 1.3)\n    let match = valueString.match(/^([+-]?[0-9]*\\.?[0-9]+(?:[eE][+-]?[0-9]+)?)\\s*(.+)$/);\n    if (!match) {\n        // Try without any space requirement for TOSCA 1.3 compatibility\n        match = valueString.match(/^([+-]?[0-9]*\\.?[0-9]+(?:[eE][+-]?[0-9]+)?)([a-zA-Z].*)$/);\n        if (!match) {\n            return null;\n        }\n    }\n\n    const numberPart = parseFloat(match[1]);\n    if (isNaN(numberPart)) {\n        return null;\n    }\n\n    const unitPart = match[2];\n    let multiplier = exports.findUnitMultiplier(unitPart, units, prefixes);\n\n    if (multiplier === null) {\n        return null;\n    }\n\n    // Calculate canonical value\n    let canonicalNumber = numberPart * multiplier;\n    let canonicalString;\n\n    if (baseType === 'integer') {\n        canonicalNumber = Math.round(canonicalNumber);\n        canonicalString = String(canonicalNumber) + ' ' + canonicalUnit;\n    } else {\n        canonicalString = String(canonicalNumber) + ' ' + canonicalUnit;\n    }\n\n    // Create scalar object with all necessary properties\n    return {\n        $originalString: valueString,\n        $number: canonicalNumber,\n        $string: canonicalString,\n        scalar: numberPart,\n        unit: unitPart,\n        baseType: baseType,\n        canonicalUnit: canonicalUnit,\n        dataTypeName: dataTypeName,\n        units: units,\n        prefixes: prefixes || {}\n    };\n};\n\n// Find unit multiplier considering prefixes\nexports.findUnitMultiplier = function(unitPart, units, prefixes) {\n    // First try direct unit match\n    let multiplier = units[unitPart];\n    \n    // Handle case-insensitive matching for TOSCA 1.3\n    if (multiplier === undefined) {\n        for (const [unit, mult] of Object.entries(units)) {\n            if (unit.toLowerCase() === unitPart.toLowerCase()) {\n                multiplier = mult;\n                break;\n            }\n        }\n    }\n\n    // Handle prefixes for TOSCA 2.0\n    if (multiplier === undefined && prefixes) {\n        // Find the longest match: prefix+unit, then unit only\n        let bestMatch = null;\n        let bestPrefixLength = 0;\n        \n        for (const [unit, unitMultiplier] of Object.entries(units)) {\n            // Check if unitPart ends with this unit\n            if (unitPart.endsWith(unit)) {\n                const potentialPrefix = unitPart.substring(0, unitPart.length - unit.length);\n                \n                if (potentialPrefix === '') {\n                    // No prefix, direct unit\n                    if (bestMatch === null || potentialPrefix.length > bestPrefixLength) {\n                        bestMatch = { unit, unitMultiplier, prefix: '', prefixMultiplier: 1 };\n                        bestPrefixLength = potentialPrefix.length;\n                    }\n                } else if (prefixes[potentialPrefix] !== undefined) {\n                    // Prefix found\n                    if (potentialPrefix.length > bestPrefixLength) {\n                        bestMatch = { \n                            unit, \n                            unitMultiplier, \n                            prefix: potentialPrefix, \n                            prefixMultiplier: prefixes[potentialPrefix] \n                        };\n                        bestPrefixLength = potentialPrefix.length;\n                    }\n                }\n            }\n        }\n        \n        if (bestMatch) {\n            multiplier = bestMatch.unitMultiplier * bestMatch.prefixMultiplier;\n        }\n    }\n\n    return multiplier !== undefined ? multiplier : null;\n};\n\n// Parse comparison arguments for constraint validators\nexports.parseComparisonArguments = function(currentPropertyValue, argumentsArray) {\n    if (argumentsArray.length === 3) {\n        // Check if this is a map key validation scenario\n        // In this case: args = [keyValue, entireMap, pattern]\n        // We should only use: [keyValue, pattern]\n        let val1 = argumentsArray[1];\n        let val2 = argumentsArray[2];\n        \n        // If val1 is an object (the entire map) and we have a string currentPropertyValue,\n        // this indicates map key validation - skip the map object\n        if (typeof currentPropertyValue === 'string' && \n            typeof val1 === 'object' && val1 !== null && \n            typeof val2 === 'string') {\n            return { val1: currentPropertyValue, val2: val2 };\n        }\n        \n        // Handle \"$value\" substitution for val1\n        if (val1 === '$value') {\n            val1 = currentPropertyValue;\n        }\n        \n        // Handle \"$value\" substitution for val2\n        if (val2 === '$value') {\n            val2 = currentPropertyValue;\n        }\n        \n        // Handle scalar parsing: if one value is a scalar object and the other is a string\n        if (val1 && typeof val1 === 'object' && val1.$number !== undefined && typeof val2 === 'string') {\n            const parsed = exports.tryParseScalar(val2, val1);\n            if (parsed) {\n                val2 = parsed;\n            }\n        } else if (val2 && typeof val2 === 'object' && val2.$number !== undefined && typeof val1 === 'string') {\n            const parsed = exports.tryParseScalar(val1, val2);\n            if (parsed) {\n                val1 = parsed;\n            }\n        }\n        \n        return { val1, val2 };\n    } else if (argumentsArray.length === 2) {\n        // Legacy calling convention: currentPropertyValue, compareValue\n        const compareValue = argumentsArray[1];\n        \n        // Handle \"$value\" substitution\n        let val2 = compareValue;\n        if (compareValue === '$value') {\n            val2 = currentPropertyValue;\n        }\n        \n        // Handle scalar parsing: if currentPropertyValue is a scalar object and val2 is a string\n        if (currentPropertyValue && typeof currentPropertyValue === 'object' && currentPropertyValue.$number !== undefined && typeof val2 === 'string') {\n            const parsed = exports.tryParseScalar(val2, currentPropertyValue);\n            if (parsed) {\n                val2 = parsed;\n            }\n        } else if (val2 && typeof val2 === 'object' && val2.$number !== undefined && typeof currentPropertyValue === 'string') {\n            const parsed = exports.tryParseScalar(currentPropertyValue, val2);\n            if (parsed) {\n                currentPropertyValue = parsed;\n            }\n        }\n        \n        return { val1: currentPropertyValue, val2: val2 };\n    } else {\n        return null;\n    }\n};\n\n// Evaluate constraint argument with potential nested functions\nexports.evaluateConstraintArgument = function(arg, currentPropertyValue) {\n    // Handle string literal \"$value\"\n    if (arg === '$value') {\n        return currentPropertyValue;\n    }\n    \n    if (typeof arg !== 'object' || arg === null || Array.isArray(arg)) {\n        return arg;\n    }\n    \n    const keys = Object.keys(arg);\n    if (keys.length === 1) {\n        const key = keys[0];\n        if (key.startsWith('$')) {\n            const functionName = key.substring(1);\n            const functionArgs = arg[key];\n            \n            // SPECIAL HANDLING: For $value or {$value: [\"path\", ...]}\n            if (functionName === 'value') {\n                if (Array.isArray(functionArgs)) {\n                    return exports.dereferencePathHelper(currentPropertyValue, functionArgs);\n                } else if (functionArgs === null || functionArgs === undefined) {\n                    return currentPropertyValue;\n                } else {\n                    return exports.dereferencePathHelper(currentPropertyValue, [functionArgs]);\n                }\n            }\n            \n            // Check if it's a validation operator (to handle recursive structure)\n            if (exports.isValidationOperator(functionName)) {\n                // Return the processed constraint for later evaluation\n                if (Array.isArray(functionArgs)) {\n                    const processedArgs = functionArgs.map(subArg => exports.evaluateConstraintArgument.call(this, subArg, currentPropertyValue));\n                    return { [key]: processedArgs };\n                } else {\n                    return { [key]: exports.evaluateConstraintArgument.call(this, functionArgs, currentPropertyValue) };\n                }\n            }\n            \n            // Try to evaluate it as a function (length, concat, etc.)\n            if (exports.isToscaFunction(functionName)) {\n                try {\n                    const functionModule = require('tosca.function.' + functionName);\n                    const processedFunctionArgs = [];\n                    const argsArray = Array.isArray(functionArgs) ? functionArgs : [functionArgs];\n                    \n                    for (const fnArg of argsArray) {\n                        processedFunctionArgs.push(exports.evaluateConstraintArgument.call(this, fnArg, currentPropertyValue));\n                    }\n                    \n                    return functionModule.evaluate.apply(this, processedFunctionArgs);\n                } catch (e) {\n                    // If the function can't be evaluated, return the processed argument\n                    if (Array.isArray(functionArgs)) {\n                        const processedArgs = functionArgs.map(subArg => exports.evaluateConstraintArgument.call(this, subArg, currentPropertyValue));\n                        return { [key]: processedArgs };\n                    } else {\n                        return { [key]: exports.evaluateConstraintArgument.call(this, functionArgs, currentPropertyValue) };\n                    }\n                }\n            }\n        }\n    }\n    \n    return arg;\n};\n\n// Validate a constraint subclause\nexports.validateConstraintSubclause = function(operatorFunctionName, originalArgs, currentPropertyValue) {\n    try {\n        const validatorModule = require('tosca.validation.' + operatorFunctionName);\n\n        if (validatorModule && typeof validatorModule.validate === 'function') {\n            const subValidator = validatorModule.validate;\n            \n            // For constraints like $greater_or_equal: [\"$value\", \"4 GB\"]\n            // We need to call: greater_or_equal.validate(currentPropertyValue, \"$value\", \"4 GB\")\n            // The individual constraint will handle \"$value\" replacement and scalar parsing\n            \n            const result = subValidator.call(this, currentPropertyValue, ...originalArgs);\n            return result;\n        } else {\n            return false; // Module or function not found\n        }\n    } catch (e) {\n        return false; // Error during sub-clause validation\n    }\n};\n\n// Helper function to dereference a path within an object\nexports.dereferencePathHelper = function(obj, pathArray) {\n    let current = obj;\n    // Handle both array paths and single property access\n    if (pathArray === undefined || pathArray === null) {\n        return current;\n    }\n    \n    // Ensure pathArray is an array, supporting {$value: \"property\"} as {$value: [\"property\"]}\n    const path = Array.isArray(pathArray) ? pathArray : [pathArray];\n\n    for (const key of path) {\n        if (current === null || typeof current !== 'object') {\n            return undefined; // Path not found or invalid intermediate value\n        }\n        \n        // Handle both object property access and array index access\n        if (Array.isArray(current)) {\n            const index = parseInt(key);\n            if (isNaN(index) || index < 0 || index >= current.length) {\n                return undefined;\n            }\n            current = current[index];\n        } else {\n            if (!current.hasOwnProperty(key)) {\n                return undefined;\n            }\n            current = current[key];\n        }\n    }\n    return current;\n};\n\n// Check if a function name corresponds to a validation operator\nexports.isValidationOperator = function(functionName) {\n    try {\n        const validatorModule = require('tosca.validation.' + functionName);\n        return validatorModule && typeof validatorModule.validate === 'function';\n    } catch (e) {\n        return false;\n    }\n};\n\n// Check if a function name corresponds to a TOSCA function\nexports.isToscaFunction = function(functionName) {\n    try {\n        const functionModule = require('tosca.function.' + functionName);\n        return functionModule && typeof functionModule.evaluate === 'function';\n    } catch (e) {\n        return false;\n    }\n};\n\n// Parse constraint subclause from map\nexports.parseConstraintSubclause = function(subclauseMap) {\n    const operatorKey = Object.keys(subclauseMap)[0];\n    if (!operatorKey) {\n        return null; // Empty or malformed sub-clause\n    }\n\n    const operatorFunctionName = operatorKey.startsWith('$') ? operatorKey.substring(1) : operatorKey;\n    let originalOperatorArgs = subclauseMap[operatorKey];\n\n    if (!Array.isArray(originalOperatorArgs)) {\n        originalOperatorArgs = [originalOperatorArgs];\n    }\n\n    return {\n        operatorFunctionName,\n        originalOperatorArgs\n    };\n};\n\nexports.validateRelationshipAttributeAccess = function(vertex, requirementName, attributeName, relationshipIndex) {\n    if (!exports.isNodeTemplate(vertex)) {\n        throw util.sprintf('node template %q not found', vertex.properties ? vertex.properties.name : 'unknown');\n    }\n    \n    // Count and find relationships by requirement name\n    let relationshipCount = 0;\n    let targetRelationship = null;\n    let relationships = [];\n    \n    for (let e = 0, l = vertex.edgesOut.size(); e < l; e++) {\n        let edge = vertex.edgesOut[e];\n        if (!exports.isTosca(edge, 'Relationship'))\n            continue;\n        \n        let relationship = edge.properties;\n        if (relationship.name === requirementName) {\n            relationships.push(relationship);\n            if (relationshipCount === relationshipIndex) {\n                targetRelationship = relationship;\n            }\n            relationshipCount++;\n        }\n    }\n    \n    // Validate that we have relationships for this requirement\n    if (relationshipCount === 0) {\n        throw util.sprintf('no relationships found for requirement %q in node template %q', \n            requirementName, vertex.properties.name);\n    }\n    \n    // Validate relationship index\n    if (relationshipIndex >= relationshipCount) {\n        throw util.sprintf('relationship index %d exceeds available relationships (%d) for requirement %q in node template %q', \n            relationshipIndex, relationshipCount, requirementName, vertex.properties.name);\n    }\n    \n    if (!targetRelationship) {\n        throw util.sprintf('relationship %q (index %d) not found in node template %q', \n            requirementName, relationshipIndex, vertex.properties.name);\n    }\n    \n    // Validate that the attribute exists in the relationship\n    if (!targetRelationship.attributes || !(attributeName in targetRelationship.attributes)) {\n        // Get relationship type name for better error message\n        let relationshipTypeName = 'unknown';\n        if (targetRelationship.types) {\n            relationshipTypeName = Object.keys(targetRelationship.types)[0] || 'unknown';\n        }\n        throw util.sprintf('attribute %q not found in relationship %q of type %q', \n            attributeName, requirementName, relationshipTypeName);\n    }\n    \n    return true;\n};\n\n// Parse scalar unit or version bound, with proper type conversion for TOSCA 1.3\nexports.parseScalarOrVersionBound = function(bound, contextValue) {\n    if (typeof bound !== 'string') {\n        return bound; // Already parsed or not a string\n    }\n    \n    // Try to parse as scalar unit using context from the value being tested\n    if (contextValue && (contextValue.$number !== undefined || contextValue.units)) {\n        const parsed = exports.tryParseScalar(bound, contextValue);\n        if (parsed) {\n            return parsed;\n        }\n    }\n    \n    // Try to parse as version if context value is a version\n    if (contextValue && contextValue.$comparer === 'tosca.comparer.version') {\n        // Check if bound looks like a version string\n        if (/^\\d+(\\.\\d+)*(\\.\\w+(-\\d+)?)?$/.test(bound)) {\n            try {\n                // Create a version object similar to contextValue\n                return {\n                    $comparer: 'tosca.comparer.version',\n                    $originalString: bound,\n                    $string: bound,\n                    // Parse version components\n                    ...exports.parseVersionString(bound)\n                };\n            } catch (e) {\n                // Fall back to string comparison\n                return bound;\n            }\n        }\n    }\n    \n    return bound; // Return as-is if no parsing applies\n};\n\n// Helper to parse version string components\nexports.parseVersionString = function(versionStr) {\n    const parts = versionStr.split('.');\n    const result = {\n        major: parseInt(parts[0]) || 0,\n        minor: parseInt(parts[1]) || 0,\n        fix: parseInt(parts[2]) || 0\n    };\n    \n    // Handle qualifier and build number (e.g., \"beta-4\")\n    if (parts.length > 3) {\n        const qualifierPart = parts[3];\n        const dashIndex = qualifierPart.indexOf('-');\n        if (dashIndex !== -1) {\n            result.qualifier = qualifierPart.substring(0, dashIndex);\n            result.build = parseInt(qualifierPart.substring(dashIndex + 1)) || 0;\n        } else {\n            result.qualifier = qualifierPart;\n            result.build = 0;\n        }\n    }\n    \n    return result;\n};"
        outputs: |-
          const traversal = require('tosca.lib.traversal');
          const tosca = require('tosca.lib.utils');

          traversal.coerce();

          if (tosca.isTosca(clout))
              transcribe.output(clout.properties.tosca.outputs);
        resolve: "const traversal = require('tosca.lib.traversal');\nconst tosca = require('tosca.lib.utils');\n\nconst enforceCapabilityOccurrences = !traversal.hasQuirk(clout, 'capabilities.occurrences.permissive');\n\n// Remove existing relationships\nlet nodeTemplateVertexes = [];\nfor (let vertexId in clout.vertexes) {\n    let vertex = clout.vertexes[vertexId];\n    if (tosca.isNodeTemplate(vertex)) {\n        nodeTemplateVertexes.push(vertex);\n        let remove = [];\n        for (let e = 0, l = vertex.edgesOut.size(); e < l; e++) {\n            let edge = vertex.edgesOut[e];\n            if (tosca.isTosca(edge, 'Relationship'))\n                remove.push(edge);\n        }\n        for (let e = 0, l = remove.length; e < l; e++)\n            remove[e].remove();\n    }\n}\n\n// For consistent results, we will sort the node templates by name\nnodeTemplateVertexes.sort(function(a, b) {\n    return a.properties.name < b.properties.name ? -1 : 1;\n});\n\ntraversal.toCoercibles();\n\n// Resolve all requirements\nfor (let v = 0, l = nodeTemplateVertexes.length; v < l; v++) {\n    let vertex = nodeTemplateVertexes[v];\n    let nodeTemplate = vertex.properties;\n    let requirements = nodeTemplate.requirements;\n    for (let r = 0, ll = requirements.length; r < ll; r++) {\n        let requirement = requirements[r];\n        resolve(vertex, nodeTemplate, requirement);\n    }\n}\n\nif (enforceCapabilityOccurrences)\n    for (let v = 0, l = nodeTemplateVertexes.length; v < l; v++) {\n        let vertex = nodeTemplateVertexes[v];\n        let nodeTemplate = vertex.properties;\n        let capabilities = nodeTemplate.capabilities;\n        for (let capabilityName in capabilities) {\n            let capability = capabilities[capabilityName];\n            let relationshipCount = countRelationships(vertex, capabilityName);\n            let minRelationshipCount = capability.minRelationshipCount;\n            if (relationshipCount < minRelationshipCount)\n                notEnoughRelationships(capability.location, relationshipCount, minRelationshipCount)\n        }\n    }\n\ntraversal.unwrapCoercibles();\n\nif (env.arguments.history !== 'false')\n    tosca.addHistory('resolve');\ntranscribe.output(clout)\n\nfunction resolve(sourceVertex, sourceNodeTemplate, requirement) {\n    let location = requirement.location;\n    let name = requirement.name;\n\n    if (isSubstituted(sourceNodeTemplate.name, name)) {\n        env.log.debugf('%s: skipping because in substitution mappings', location.path)\n        return;\n    }\n\n    let candidates = gatherCandidateNodeTemplates(sourceVertex, requirement);\n    \n    if (candidates.length === 0) {\n        unsatisfied(location, name, 'there are no candidate node templates');\n        return;\n    }\n\n    candidates = gatherCandidateCapabilities(requirement, candidates);\n    \n    if (candidates.length === 0) {\n        unsatisfied(location, name, 'no candidate node template provides required capability');\n        return;\n    }\n\n    // Gather priority candidates: those that have not yet fulfilled their minimum relationship count\n    let priorityCandidates = [];\n    for (let c = 0, l = candidates.length; c < l; c++) {\n        let candidate = candidates[c];\n        if ((candidate.capability.minRelationshipCount !== 0) && (countRelationships(candidate.vertex, candidate.capabilityName) < candidate.capability.minRelationshipCount))\n            priorityCandidates.push(candidate);\n    }\n\n    let chosen = null;\n\n    if (priorityCandidates.length !== 0)\n        // Of the priority candidates, pick the one with the highest minimum relationship count\n        // (needs to be fulfilled soonest)\n        for (let c = 0, l = priorityCandidates.length; c < l; c++) {\n            let candidate = priorityCandidates[c];\n            if ((chosen === null) || (candidate.capability.minRelationshipCount > chosen.capability.minRelationshipCount))\n                chosen = candidate;\n        }\n    else\n        // Of the candidates, pick the one with the highest maximum relationship count\n        // (has the most room)\n        for (let c = 0, l = candidates.length; c < l; c++) {\n            let candidate = candidates[c];\n            if ((chosen === null) || isMaxCountGreater(candidate.capability.maxRelationshipCount, chosen.capability.maxRelationshipCount))\n                chosen = candidate;\n        }\n\n    env.log.debugf('%s: satisfied %q with capability %q in node template %q', location.path, name, chosen.capabilityName, chosen.nodeTemplateName);\n    addRelationship(sourceVertex, requirement, chosen.vertex, chosen.capabilityName);\n}\n\nfunction gatherCandidateNodeTemplates(sourceVertex, requirement) {\n    let path = requirement.location.path;\n    let nodeTemplateName = requirement.nodeTemplateName;\n    let nodeTypeName = requirement.nodeTypeName;\n    let nodeTemplatePropertyValidators = requirement.nodeTemplatePropertyValidators;\n    let capabilityPropertyValidatorsMap = requirement.capabilityPropertyValidators;\n\n    let candidates = [];\n    for (let v = 0, l = nodeTemplateVertexes.length; v < l; v++) {\n        let vertex = nodeTemplateVertexes[v];\n        let candidateNodeTemplate = vertex.properties;\n        let candidateNodeTemplateName = candidateNodeTemplate.name;\n\n        if ((nodeTemplateName !== '') && (nodeTemplateName !== candidateNodeTemplateName)) {\n            env.log.debugf('%s: node template %q is not named %q', path, candidateNodeTemplateName, nodeTemplateName);\n            continue;\n        }\n\n        if ((nodeTypeName !== '') && !(nodeTypeName in candidateNodeTemplate.types)) {\n            env.log.debugf('%s: node template %q is not of type %q', path, candidateNodeTemplateName, nodeTypeName);\n            continue;\n        }\n\n        let candidateCapabilities = candidateNodeTemplate.capabilities;\n\n        // CRITICAL FIX: Check if the node has any compatible capabilities BEFORE applying node_filter\n        // This prevents evaluation of node_filter on nodes that can't satisfy the requirement anyway\n        let hasCompatibleCapability = false;\n        let capabilityName = requirement.capabilityName;\n        let capabilityTypeName = requirement.capabilityTypeName;\n\n        for (let candidateCapabilityName in candidateCapabilities) {\n            let candidateCapability = candidateCapabilities[candidateCapabilityName];\n\n            // Check if this capability could match the requirement\n            let capabilityNameMatches = (capabilityName === '') || (capabilityName === candidateCapabilityName);\n            let capabilityTypeMatches = (capabilityTypeName === '') || (capabilityTypeName in candidateCapability.types);\n\n            if (capabilityNameMatches && capabilityTypeMatches) {\n                hasCompatibleCapability = true;\n                break;\n            }\n        }\n\n        if (!hasCompatibleCapability) {\n            env.log.debugf('%s: node template %q has no compatible capabilities for requirement (capability: %q, type: %q)', \n                path, candidateNodeTemplateName, capabilityName, capabilityTypeName);\n            continue;\n        }\n\n        // NOW it's safe to apply node_filter since we know the node has compatible capabilities\n        if ((Object.keys(nodeTemplatePropertyValidators).length !== 0) && !arePropertiesValid(path, sourceVertex, 'node template', candidateNodeTemplateName, candidateNodeTemplate, nodeTemplatePropertyValidators)) {\n            env.log.debugf('%s: properties of node template %q do not validate', path, candidateNodeTemplateName);\n            continue;\n        }\n\n        // Capability filter\n        if (Object.keys(capabilityPropertyValidatorsMap).length !== 0) {\n            let valid = true;\n            for (let candidateCapabilityName in candidateCapabilities) {\n                let candidateCapability = candidateCapabilities[candidateCapabilityName];\n\n                // Try by name\n                let capabilityPropertyValidators = capabilityPropertyValidatorsMap[candidateCapabilityName];\n                if (capabilityPropertyValidators === undefined) {\n                    // Try by type name\n                    for (let candidateTypeName in candidateCapability.types) {\n                        capabilityPropertyValidators = capabilityPropertyValidatorsMap[candidateTypeName];\n                        if (capabilityPropertyValidators !== undefined) break;\n                    }\n                }\n\n                if ((capabilityPropertyValidators !== undefined) && (capabilityPropertyValidators.length !== 0) && !arePropertiesValid(path, sourceVertex, 'capability', candidateCapabilityName, candidateCapability, capabilityPropertyValidators)) {\n                    env.log.debugf('%s: properties of capability %q in node template %q do not validate', path, candidateCapabilityName, candidateNodeTemplateName);\n                    valid = false;\n                    break;\n                }\n            }\n            if (!valid)\n                continue;\n        }\n\n        candidates.push({\n            vertex: vertex,\n            nodeTemplateName: candidateNodeTemplateName,\n            capabilities: candidateCapabilities\n        });\n    }\n\n    return candidates;\n}\n\nfunction gatherCandidateCapabilities(requirement, candidateNodeTemplates) {\n    let path = requirement.location.path;\n    let capabilityName = requirement.capabilityName;\n    let capabilityTypeName = requirement.capabilityTypeName;\n\n    let candidates = [];\n    for (let c = 0, l = candidateNodeTemplates.length; c < l; c++) {\n        let candidate = candidateNodeTemplates[c];\n        let candidateVertex = candidate.vertex;\n        let candidateNodeTemplateName = candidate.nodeTemplateName;\n\n        let candidateCapabilities = [];\n        for (let candidateCapabilityName in candidate.capabilities) {\n            candidateCapabilities.push({\n                name: candidateCapabilityName,\n                capability: candidate.capabilities[candidateCapabilityName]\n            });\n        }\n\n        // For consistent results, we will sort the candidate capabilities by name\n        candidateCapabilities.sort(function(a, b) {\n            return a.name < b.name ? -1 : 1;\n        });\n\n        for (let cc = 0, ll = candidateCapabilities.length; cc < ll; cc++) {\n            let candidateCapabilityName = candidateCapabilities[cc].name;\n\n            if ((capabilityName !== '') && (capabilityName !== candidateCapabilityName)) {\n                env.log.debugf('%s: capability %q in node template %q is not named %q', path, candidateCapabilityName, candidateNodeTemplateName, capabilityName);\n                continue;\n            }\n\n            let candidateCapability = candidateCapabilities[cc].capability;\n\n            if ((capabilityTypeName !== '') && !(capabilityTypeName in candidateCapability.types)) {\n                env.log.debugf('%s: capability %q in node template %q is not of type %q', path, candidateCapabilityName, candidateNodeTemplateName, capabilityTypeName);\n                continue;\n            }\n\n            // TOSCA 2.0: Validate relationship type valid_capability_types\n            if (requirement.relationship && requirement.relationship.types) {\n                let relationshipTypeValidationFailed = false;\n                for (let relationshipTypeName in requirement.relationship.types) {\n                    let relationshipType = requirement.relationship.types[relationshipTypeName];\n                    \n                    // Debug: Log the relationship type structure\n                    env.log.debugf('%s: Examining relationship type %q: %s', \n                        path, relationshipTypeName, JSON.stringify(relationshipType, null, 2));\n                    \n                    // Check valid_capability_types (TOSCA 2.0) or valid_target_types (TOSCA 1.3 compatibility)\n                    let validCapabilityTypes = relationshipType.validCapabilityTypes || relationshipType.validTargetTypes;\n                    \n                    env.log.debugf('%s: validCapabilityTypes for %q: %s', \n                        path, relationshipTypeName, validCapabilityTypes ? JSON.stringify(validCapabilityTypes) : 'null');\n                    \n                    if (validCapabilityTypes && validCapabilityTypes.length > 0) {\n                        let capabilityTypeValid = false;\n                        \n                        env.log.debugf('%s: Checking candidate capability types: %s', \n                            path, Object.keys(candidateCapability.types).join(', '));\n                        \n                        // Check if any of the candidate capability's types are in the valid list\n                        for (let candidateCapabilityTypeName in candidateCapability.types) {\n                            for (let v = 0; v < validCapabilityTypes.length; v++) {\n                                if (candidateCapabilityTypeName === validCapabilityTypes[v]) {\n                                    capabilityTypeValid = true;\n                                    env.log.debugf('%s: Found matching capability type: %q', \n                                        path, candidateCapabilityTypeName);\n                                    break;\n                                }\n                            }\n                            if (capabilityTypeValid) break;\n                        }\n                        \n                        if (!capabilityTypeValid) {\n                            env.log.debugf('%s: capability %q (types: %s) in node template %q is not valid for relationship type %q (valid_capability_types: %s)', \n                                path, candidateCapabilityName, Object.keys(candidateCapability.types).join(', '), \n                                candidateNodeTemplateName, relationshipTypeName, validCapabilityTypes.join(', '));\n                            relationshipTypeValidationFailed = true;\n                            break;\n                        }\n                    } else {\n                        env.log.debugf('%s: No valid_capability_types constraint for relationship type %q', \n                            path, relationshipTypeName);\n                    }\n                }\n                \n                if (relationshipTypeValidationFailed) {\n                    env.log.debugf('%s: Rejecting candidate due to relationship type validation failure', path);\n                    continue;\n                }\n            }\n\n            if (enforceCapabilityOccurrences) {\n                let maxRelationshipCount = candidateCapability.maxRelationshipCount;\n                if ((maxRelationshipCount !== -1) && (countRelationships(candidateVertex, candidateCapabilityName) === maxRelationshipCount)) {\n                    env.log.debugf('%s: capability %q in node template %q already has %d relationships, the maximum allowed', path, candidateCapabilityName, candidateNodeTemplateName, maxRelationshipCount);\n                    continue;\n                }\n            }\n\n            candidates.push({\n                vertex: candidateVertex,\n                nodeTemplateName: candidateNodeTemplateName,\n                capability: candidateCapability,\n                capabilityName: candidateCapabilityName\n            });\n        }\n    }\n\n    return candidates;\n}\n\nfunction addRelationship(sourceVertex, requirement, targetVertex, capabilityName) {\n    let edge = sourceVertex.newEdgeTo(targetVertex);\n    edge.metadata['puccini'] = {\n        version: '1.0',\n        kind: 'Relationship'\n    };\n\n    let relationship = requirement.relationship;\n    if (relationship)\n        edge.properties = {\n            name: requirement.name,\n            description: relationship.description,\n            types: relationship.types,\n            properties: relationship.properties,\n            attributes: relationship.attributes,\n            interfaces: relationship.interfaces,\n            capability: capabilityName\n        };\n    else\n        // Untyped relationship\n        edge.properties = {\n            name: requirement.name,\n            description: '',\n            types: {},\n            properties: {},\n            attributes: {},\n            interfaces: {},\n            capability: capabilityName\n        };\n}\n\nfunction countRelationships(vertex, capabilityName) {\n    let count = 0;\n    for (let e = 0, l = vertex.edgesIn.size(); e < l; e++) {\n        let edge = vertex.edgesIn[e];\n        if (tosca.isTosca(edge, 'Relationship') && (edge.properties.capability === capabilityName))\n            count++;\n    }\n    return count;\n}\n\nfunction arePropertiesValid(path, sourceVertex, kind, name, entity, validatorsMap) {\n    let valid = true;\n\n    // Handle special node filter case\n    if (validatorsMap['$node_filter']) {\n        let validators = validatorsMap['$node_filter'];\n        \n        // Create validators object with the candidate entity as context\n        // For node filters, SELF should refer to the candidate node being evaluated\n        let candidateVertex = null;\n        \n        // Find the vertex for this entity\n        for (let vertexId in clout.vertexes) {\n            let vertex = clout.vertexes[vertexId];\n            if (tosca.isNodeTemplate(vertex) && vertex.properties.name === entity.name) {\n                candidateVertex = vertex;\n                break;\n            }\n        }\n        \n        if (!candidateVertex) {\n            return false;\n        }\n        \n        // Create validators with the candidate vertex as the evaluation context\n        // This ensures that SELF in $get_property calls refers to the candidate node\n        let validatorsObj = clout.newValidators(validators, candidateVertex, candidateVertex, candidateVertex);\n        \n        // For node filters, we validate against the entire entity (node template)\n        let isValid = validatorsObj.isValid(entity);\n        if (!isValid) {\n            return false;\n        }\n    }\n\n    // Handle regular property validation\n    let properties = entity.properties;\n    for (let propertyName in validatorsMap) {\n        // Skip the special node filter key\n        if (propertyName === '$node_filter') {\n            continue;\n        }\n        \n        env.log.debugf('%s: applying validators to property %q of %s %q', path, propertyName, kind, name);\n\n        let property = properties[propertyName];\n        if (property === undefined) {\n            // return false; GOJA: returning from inside for-loop is broken\n            valid = false;\n            break;\n        }\n\n        let validators = validatorsMap[propertyName];\n        validators = clout.newValidators(validators, sourceVertex, sourceVertex, entity)\n        let isValid = validators.isValid(property);\n        if (!isValid) {\n            // return false; GOJA: returning from inside for-loop is broken\n            valid = false;\n            break;\n        }\n    }\n\n    return valid;\n}\n\nfunction isSubstituted(nodeTemplateName, requirementName) {\n    for (let vertexId in clout.vertexes) {\n        let vertex = clout.vertexes[vertexId];\n        if (tosca.isTosca(vertex, 'Substitution')) {\n            for (let e = 0, l = vertex.edgesOut.size(); e < l; e++) {\n                let edge = vertex.edgesOut[e];\n                if (!tosca.isTosca(edge, 'RequirementPointer'))\n                    continue;\n\n                if ((edge.target.properties.name === nodeTemplateName) && (edge.properties.target === requirementName))\n                    return true;\n            }\n\n            // There's only ever one substitution\n            return false;\n        }\n    }\n\n    return false;\n}\n\nfunction isMaxCountGreater(a, b) {\n    if (a == -1)\n        return b !== -1;\n    else if (b == -1)\n        return false;\n    return a > b;\n}\n\nfunction unsatisfied(location, name, message) {\n    if (typeof problems === 'undefined')\n        throw util.sprintf('%s: could not satisfy %q because %s', location.path, name, message);\n    else\n        problems.reportFull(11, 'Resolution', location.path, util.sprintf('could not satisfy %q because %s', name, message), location.row, location.column);\n}\n\nfunction notEnoughRelationships(location, relationshipCount, minRelationshipCount) {\n    if (typeof problems === 'undefined')\n        throw util.sprintf('%s: not enough relationships: %d < %d', location.path, relationshipCount, minRelationshipCount);\n    else\n        problems.reportFull(11, 'Resolution', location.path, util.sprintf('not enough relationships: %d < %d', relationshipCount, minRelationshipCount), location.row, location.column);\n}"
        validation:
          _format: |-
            exports.validate = function(v, format) {
              if (arguments.length !== 2)
                throw 'must have 1 argument';
              if (!util.isType(v, 'ard.string'))
                return 'not a string';
              try {
                ard.validateFormat(v, format);
              } catch (x) {
                if (x.value && x.value.error)
                  // Unwrap Go error
                  return x.value.error();
                else
                  throw x;
              }
              return true;
            };
          and: "// and.js\n// TOSCA 2.0 logical operator: and\nconst tosca = require('tosca.lib.utils');\n\nexports.validate = function(currentPropertyValue) {\n    // Empty AND is vacuously true\n    if (arguments.length <= 1) {\n        return true;\n    }\n\n    // Process each sub-clause\n    for (let i = 1; i < arguments.length; i++) {\n        const subclauseArg = arguments[i];\n        \n        // Handle structured objects from parser\n        if (subclauseArg && typeof subclauseArg === 'object' && subclauseArg.Operator && subclauseArg.Arguments) {\n            // This is a structured constraint object from the parser\n            const operatorName = subclauseArg.Operator;\n            const constraintArgs = subclauseArg.Arguments || [];\n            \n            // Validate the structured subclause\n            const isSubclauseValid = tosca.validateConstraintSubclause.call(this, operatorName, constraintArgs, currentPropertyValue);\n            \n            if (!isSubclauseValid) {\n                return false; // Short-circuit on first failure\n            }\n            continue;\n        }\n        \n        // Handle simple constraint map format (legacy)\n        const subclauseMap = subclauseArg;\n        \n        // Parse the subclause\n        const parsed = tosca.parseConstraintSubclause(subclauseMap);\n        if (!parsed) {\n            return false; // Malformed sub-clause -> fail AND\n        }\n\n        const { operatorFunctionName, originalOperatorArgs } = parsed;\n\n        // Process arguments - handle complex objects but preserve simple \"$value\" strings\n        const processedArgs = [];\n        for (const arg of originalOperatorArgs) {\n            let processed;\n            if (arg === '$value') {\n                // Handle string literal \"$value\" - don't process, let individual constraints handle it\n                processed = arg;\n            } else if (typeof arg === 'object' && arg !== null && !Array.isArray(arg)) {\n                // Handle complex objects like {\"$value\":[\"count\"]} - these need processing\n                processed = tosca.evaluateConstraintArgument.call(this, arg, currentPropertyValue);\n            } else {\n                // Handle arrays and primitives - pass through\n                processed = arg;\n            }\n            processedArgs.push(processed);\n        }\n        \n        // Validate the subclause\n        const isSubclauseValid = tosca.validateConstraintSubclause.call(this, operatorFunctionName, processedArgs, currentPropertyValue);\n        \n        if (!isSubclauseValid) {\n            return false; // Short-circuit on first failure\n        }\n    }\n\n    return true; // All clauses passed\n};"
          contains: "// TOSCA 2.0 operator: contains\nconst tosca = require('tosca.lib.utils');\n\nexports.validate = function(currentPropertyValue) {\n    const parsed = tosca.parseComparisonArguments(currentPropertyValue, arguments);\n    if (!parsed) {\n        return false;\n    }\n    \n    const valueToTest = parsed.val1;\n    const searchValue = parsed.val2;\n    \n    // Validate arguments\n    if (valueToTest === undefined || valueToTest === null) {\n        return false;\n    }\n    \n    if (searchValue === undefined || searchValue === null) {\n        return false;\n    }\n    \n    // Handle string case\n    if (typeof valueToTest === 'string') {\n        if (typeof searchValue === 'string') {\n            return valueToTest.includes(searchValue);\n        } else {\n            return false;\n        }\n    }\n    \n    // Handle list case\n    if (Array.isArray(valueToTest)) {\n        if (Array.isArray(searchValue)) {\n            // Check if searchValue (sublist) is contained in valueToTest as an uninterrupted sequence\n            if (searchValue.length === 0) {\n                return true; // Empty array is contained in any array\n            }\n            \n            if (searchValue.length > valueToTest.length) {\n                return false; // Can't contain a longer sequence\n            }\n            \n            // Look for the uninterrupted sequence in the array\n            for (let i = 0; i <= valueToTest.length - searchValue.length; i++) {\n                let sequenceFound = true;\n                \n                for (let j = 0; j < searchValue.length; j++) {\n                    if (!tosca.deepEqual(valueToTest[i + j], searchValue[j])) {\n                        sequenceFound = false;\n                        break;\n                    }\n                }\n                \n                if (sequenceFound) {\n                    return true;\n                }\n            }\n            \n            return false;\n        } else {\n            // Check if single value is contained in list\n            for (let i = 0; i < valueToTest.length; i++) {\n                if (tosca.deepEqual(valueToTest[i], searchValue)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n    }\n    \n    // Invalid types\n    return false;\n};"
          equal: "// [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3\n// [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3\n// [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2\n// [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2\n\nconst tosca = require('tosca.lib.utils');\n\nexports.validate = function(currentPropertyValue) {\n    const parsed = tosca.parseComparisonArguments(currentPropertyValue, arguments);\n    if (!parsed) {\n        return false;\n    }\n    \n    const comparable1 = tosca.getComparable(parsed.val1);\n    const comparable2 = tosca.getComparable(parsed.val2);\n    \n    return comparable1 === comparable2;\n};"
          greater_or_equal: "// [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3\n// [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3\n// [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2\n// [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2\n\nconst tosca = require('tosca.lib.utils');\n\nexports.validate = function(currentPropertyValue) {\n    const parsed = tosca.parseComparisonArguments(currentPropertyValue, arguments);\n    if (!parsed) {\n        return false;\n    }\n    \n    return tosca.compare(parsed.val1, parsed.val2) >= 0;\n};"
          greater_than: "// [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3\n// [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3\n// [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2\n// [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2\n\nconst tosca = require('tosca.lib.utils');\n\nexports.validate = function(currentPropertyValue) {\n    const parsed = tosca.parseComparisonArguments(currentPropertyValue, arguments);\n    if (!parsed) {\n        return false;\n    }\n    \n    return tosca.compare(parsed.val1, parsed.val2) > 0;\n};"
          has_all_entries: "// TOSCA 2.0 operator: has_all_entries\nconst tosca = require('tosca.lib.utils');\n\nexports.validate = function(currentPropertyValue) {\n    const parsed = tosca.parseComparisonArguments(currentPropertyValue, arguments);\n    if (!parsed) {\n        return false;\n    }\n    \n    const container = parsed.val1;\n    const requiredEntries = parsed.val2;\n    \n    // Validate arguments\n    if (container === undefined || container === null) {\n        return false;\n    }\n    \n    if (requiredEntries === undefined || requiredEntries === null) {\n        return false;\n    }\n    \n    // Second argument must be a list\n    if (!Array.isArray(requiredEntries)) {\n        return false;\n    }\n    \n    // Empty required entries list is always satisfied\n    if (requiredEntries.length === 0) {\n        return true;\n    }\n    \n    // Handle list case\n    if (Array.isArray(container)) {\n        // Check if ALL entries in requiredEntries exist in the container list\n        for (let i = 0; i < requiredEntries.length; i++) {\n            let found = false;\n            for (let j = 0; j < container.length; j++) {\n                if (tosca.deepEqual(container[j], requiredEntries[i])) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    // Handle map case\n    if (typeof container === 'object' && container !== null && !Array.isArray(container)) {\n        // Check if ALL entries in requiredEntries exist as values in the container map\n        for (let i = 0; i < requiredEntries.length; i++) {\n            let found = false;\n            for (let key in container) {\n                if (container.hasOwnProperty(key)) {\n                    if (tosca.deepEqual(container[key], requiredEntries[i])) {\n                        found = true;\n                        break;\n                    }\n                }\n            }\n            if (!found) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    // Invalid container type\n    return false;\n};"
          has_all_keys: "// TOSCA 2.0 operator: has_all_keys\nconst tosca = require('tosca.lib.utils');\n\nexports.validate = function(currentPropertyValue) {\n    const parsed = tosca.parseComparisonArguments(currentPropertyValue, arguments);\n    if (!parsed) {\n        return false;\n    }\n    \n    const mapToTest = parsed.val1;\n    const requiredKeys = parsed.val2;\n    \n    // Validate arguments\n    if (mapToTest === undefined || mapToTest === null) {\n        return false;\n    }\n    \n    if (requiredKeys === undefined || requiredKeys === null) {\n        return false;\n    }\n    \n    // First argument must be a map (object)\n    if (typeof mapToTest !== 'object' || Array.isArray(mapToTest)) {\n        return false;\n    }\n    \n    // Second argument must be a list\n    if (!Array.isArray(requiredKeys)) {\n        return false;\n    }\n    \n    // Empty required keys list is always satisfied\n    if (requiredKeys.length === 0) {\n        return true;\n    }\n    \n    // Check if ALL keys in requiredKeys exist in the map\n    for (let i = 0; i < requiredKeys.length; i++) {\n        if (!mapToTest.hasOwnProperty(requiredKeys[i])) {\n            return false;\n        }\n    }\n    \n    return true;\n};"
          has_any_entry: "// TOSCA 2.0 operator: has_any_entry\nconst tosca = require('tosca.lib.utils');\n\nexports.validate = function(currentPropertyValue) {\n    const parsed = tosca.parseComparisonArguments(currentPropertyValue, arguments);\n    if (!parsed) {\n        return false;\n    }\n    \n    const container = parsed.val1;\n    const candidateEntries = parsed.val2;\n    \n    // Validate arguments\n    if (container === undefined || container === null) {\n        return false;\n    }\n    \n    if (candidateEntries === undefined || candidateEntries === null) {\n        return false;\n    }\n    \n    // Second argument must be a list\n    if (!Array.isArray(candidateEntries)) {\n        return false;\n    }\n    \n    // Empty candidate entries list always returns false\n    if (candidateEntries.length === 0) {\n        return false;\n    }\n    \n    // Handle list case\n    if (Array.isArray(container)) {\n        // Check if ANY entry in candidateEntries exists in the container list\n        for (let i = 0; i < candidateEntries.length; i++) {\n            for (let j = 0; j < container.length; j++) {\n                if (tosca.deepEqual(container[j], candidateEntries[i])) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    \n    // Handle map case\n    if (typeof container === 'object' && container !== null && !Array.isArray(container)) {\n        // Check if ANY entry in candidateEntries exists as a value in the container map\n        for (let i = 0; i < candidateEntries.length; i++) {\n            for (let key in container) {\n                if (container.hasOwnProperty(key)) {\n                    if (tosca.deepEqual(container[key], candidateEntries[i])) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    \n    // Invalid container type\n    return false;\n};"
          has_any_key: "// TOSCA 2.0 operator: has_any_key\nconst tosca = require('tosca.lib.utils');\n\nexports.validate = function(currentPropertyValue) {\n    const parsed = tosca.parseComparisonArguments(currentPropertyValue, arguments);\n    if (!parsed) {\n        return false;\n    }\n    \n    const mapToTest = parsed.val1;\n    const candidateKeys = parsed.val2;\n    \n    // Validate arguments\n    if (mapToTest === undefined || mapToTest === null) {\n        return false;\n    }\n    \n    if (candidateKeys === undefined || candidateKeys === null) {\n        return false;\n    }\n    \n    // First argument must be a map (object)\n    if (typeof mapToTest !== 'object' || Array.isArray(mapToTest)) {\n        return false;\n    }\n    \n    // Second argument must be a list\n    if (!Array.isArray(candidateKeys)) {\n        return false;\n    }\n    \n    // Empty candidate keys list always returns false\n    if (candidateKeys.length === 0) {\n        return false;\n    }\n    \n    // Check if ANY key in candidateKeys exists in the map\n    for (let i = 0; i < candidateKeys.length; i++) {\n        if (mapToTest.hasOwnProperty(candidateKeys[i])) {\n            return true;\n        }\n    }\n    \n    return false;\n};"
          has_entry: "// TOSCA 2.0 constraint: has_entry\nconst tosca = require('tosca.lib.utils');\n\nexports.validate = function(currentPropertyValue) {\n    const parsed = tosca.parseComparisonArguments(currentPropertyValue, arguments);\n    if (!parsed) {\n        return false;\n    }\n    \n    const container = parsed.val1;\n    const valueToFind = parsed.val2;\n    \n    if (container === undefined || container === null) {\n        return false;\n    }\n    \n    // Handle list/array case\n    if (Array.isArray(container)) {\n        for (let i = 0; i < container.length; i++) {\n            const comparable1 = tosca.getComparable(container[i]);\n            const comparable2 = tosca.getComparable(valueToFind);\n            if (comparable1 === comparable2) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    // Handle map/object case\n    if (typeof container === 'object' && container !== null) {\n        // Check if any value in the map matches\n        for (const key in container) {\n            if (container.hasOwnProperty(key)) {\n                const comparable1 = tosca.getComparable(container[key]);\n                const comparable2 = tosca.getComparable(valueToFind);\n                if (comparable1 === comparable2) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    \n    // Invalid container type\n    return false;\n};"
          has_key: "// TOSCA 2.0 constraint: has_key\n\nconst tosca = require('tosca.lib.utils');\n\nexports.validate = function(currentPropertyValue) {\n    const parsed = tosca.parseComparisonArguments(currentPropertyValue, arguments);\n    if (!parsed) {\n        return false;\n    }\n    \n    const mapValue = parsed.val1;\n    const keyToFind = parsed.val2;\n    \n    if (!mapValue || typeof mapValue !== 'object' || Array.isArray(mapValue)) {\n        return false;\n    }\n    \n    return mapValue.hasOwnProperty(keyToFind);\n};"
          has_prefix: "// TOSCA 2.0 operator: has_prefix\nconst tosca = require('tosca.lib.utils');\n\nexports.validate = function(currentPropertyValue) {\n    const parsed = tosca.parseComparisonArguments(currentPropertyValue, arguments);\n    if (!parsed) {\n        return false;\n    }\n    \n    const valueToTest = parsed.val1;\n    const prefix = parsed.val2;\n    \n    // Validate arguments\n    if (valueToTest === undefined || valueToTest === null) {\n        return false;\n    }\n    \n    if (prefix === undefined || prefix === null) {\n        return false;\n    }\n    \n    // Both arguments must be of the same type (string or list)\n    if (typeof valueToTest !== typeof prefix) {\n        return false;\n    }\n    \n    // Handle string case\n    if (typeof valueToTest === 'string' && typeof prefix === 'string') {\n        return valueToTest.startsWith(prefix);\n    }\n    \n    // Handle list case\n    if (Array.isArray(valueToTest) && Array.isArray(prefix)) {\n        // Check if prefix list is longer than the value list\n        if (prefix.length > valueToTest.length) {\n            return false;\n        }\n        \n        // Check if the first elements of valueToTest match prefix\n        for (let i = 0; i < prefix.length; i++) {\n            if (!tosca.deepEqual(valueToTest[i], prefix[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    // Invalid types\n    return false;\n};"
          has_suffix: "// TOSCA 2.0 operator: has_suffix\nconst tosca = require('tosca.lib.utils');\n\nexports.validate = function(currentPropertyValue) {\n    const parsed = tosca.parseComparisonArguments(currentPropertyValue, arguments);\n    if (!parsed) {\n        return false;\n    }\n    \n    const valueToTest = parsed.val1;\n    const suffix = parsed.val2;\n    \n    // Validate arguments\n    if (valueToTest === undefined || valueToTest === null) {\n        return false;\n    }\n    \n    if (suffix === undefined || suffix === null) {\n        return false;\n    }\n    \n    // Both arguments must be of the same type (string or list)\n    if (typeof valueToTest !== typeof suffix) {\n        return false;\n    }\n    \n    // Handle string case\n    if (typeof valueToTest === 'string' && typeof suffix === 'string') {\n        return valueToTest.endsWith(suffix);\n    }\n    \n    // Handle list case\n    if (Array.isArray(valueToTest) && Array.isArray(suffix)) {\n        // Check if suffix list is longer than the value list\n        if (suffix.length > valueToTest.length) {\n            return false;\n        }\n        \n        // Check if the last elements of valueToTest match suffix\n        const startIndex = valueToTest.length - suffix.length;\n        for (let i = 0; i < suffix.length; i++) {\n            if (!tosca.deepEqual(valueToTest[startIndex + i], suffix[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    \n    // Invalid types\n    return false;\n};"
          in_range: "// [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3\n// [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3\n// [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2\n// [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2\n\nconst tosca = require('tosca.lib.utils');\n\nexports.validate = function(currentPropertyValue) {\n    // First handle the case where we're being incorrectly called with a list value in a list context\n    if (arguments.length === 3 && Array.isArray(arguments[1]) && Array.isArray(arguments[2])) {\n        // This indicates we're incorrectly being called with in_range(firstElement, entireList, bounds)\n        // Let's validate each element individually\n        const firstElement = currentPropertyValue; // First element already extracted\n        const valuesList = arguments[1];\n        const bounds = arguments[2];\n        \n        // Check if the first element is in range\n        if (tosca.compare(firstElement, bounds[0]) < 0 || tosca.compare(firstElement, bounds[1]) > 0) {\n            return false;\n        }\n        \n        // Check remaining elements in the list\n        for (let i = 1; i < valuesList.length; i++) {\n            if (tosca.compare(valuesList[i], bounds[0]) < 0 || tosca.compare(valuesList[i], bounds[1]) > 0) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n    \n    if (arguments.length === 3) {\n        // TOSCA 1.3 syntax: constraint calls in_range(currentValue, lowerBound, upperBound)\n        // Or TOSCA 2.0 syntax: $in_range: [ <value_to_test>, [<lower_bound>, <upper_bound>] ]\n        let valueToTest = arguments[1];\n        let secondArg = arguments[2];\n        \n        // Handle \"$value\" substitution for valueToTest\n        if (valueToTest === '$value') {\n            valueToTest = currentPropertyValue;\n        }\n\n        if (valueToTest === undefined || valueToTest === null) {\n            return false;\n        }\n        \n        // Check if this is TOSCA 2.0 syntax with bounds array\n        if (Array.isArray(secondArg) && secondArg.length === 2) {\n            let lowerBound = secondArg[0];\n            let upperBound = secondArg[1];\n\n            if (lowerBound === undefined || lowerBound === null ||\n                upperBound === undefined || upperBound === null) {\n                return false;\n            }\n\n            // Parse bounds with scalar context\n            lowerBound = tosca.parseScalarOrVersionBound(lowerBound, valueToTest);\n            upperBound = tosca.parseScalarOrVersionBound(upperBound, valueToTest);\n\n            return (tosca.compare(valueToTest, lowerBound) >= 0) && \n                   (tosca.compare(valueToTest, upperBound) <= 0);\n        } else {\n            // TOSCA 1.3 syntax: in_range(currentValue, lowerBound, upperBound)\n            // Here valueToTest is actually the current value, secondArg is lowerBound\n            // We need to get the third argument as upperBound\n            let lowerBound = valueToTest; // arguments[1]\n            let upperBound = secondArg;   // arguments[2]\n            valueToTest = currentPropertyValue; // The actual value being tested\n            \n            if (lowerBound === undefined || lowerBound === null ||\n                upperBound === undefined || upperBound === null) {\n                return false;\n            }\n\n            // Parse bounds with scalar context for TOSCA 1.3\n            lowerBound = tosca.parseScalarOrVersionBound(lowerBound, valueToTest);\n            upperBound = tosca.parseScalarOrVersionBound(upperBound, valueToTest);\n\n            return (tosca.compare(valueToTest, lowerBound) >= 0) && \n                   (tosca.compare(valueToTest, upperBound) <= 0);\n        }\n               \n    } else if (arguments.length === 2) {\n        const secondArg = arguments[1];\n        \n        // Check if this is the nested array syntax: [ $value, [bounds] ]\n        if (Array.isArray(secondArg) && secondArg.length === 2) {\n            const firstElement = secondArg[0];\n            const secondElement = secondArg[1];\n            \n            // TOSCA 2.0 style: [ $value, [lower, upper] ]\n            if ((firstElement === '$value' || typeof firstElement !== 'undefined') && \n                Array.isArray(secondElement) && secondElement.length === 2) {\n                \n                let valueToTest = firstElement === '$value' ? currentPropertyValue : firstElement;\n                let lowerBound = secondElement[0];\n                let upperBound = secondElement[1];\n                \n                if (valueToTest === undefined || valueToTest === null ||\n                    lowerBound === undefined || lowerBound === null ||\n                    upperBound === undefined || upperBound === null) {\n                    return false;\n                }\n\n                // Parse bounds with scalar context\n                lowerBound = tosca.parseScalarOrVersionBound(lowerBound, valueToTest);\n                upperBound = tosca.parseScalarOrVersionBound(upperBound, valueToTest);\n\n                return (tosca.compare(valueToTest, lowerBound) >= 0) && \n                       (tosca.compare(valueToTest, upperBound) <= 0);\n            }\n            \n            // TOSCA 1.3 style: [lower, upper] (two bounds directly)\n            if (typeof firstElement === 'number' || typeof firstElement === 'string') {\n                let lowerBound = firstElement;\n                let upperBound = secondElement;\n                \n                // Parse bounds with scalar context\n                lowerBound = tosca.parseScalarOrVersionBound(lowerBound, currentPropertyValue);\n                upperBound = tosca.parseScalarOrVersionBound(upperBound, currentPropertyValue);\n\n                return (tosca.compare(currentPropertyValue, lowerBound) >= 0) && \n                       (tosca.compare(currentPropertyValue, upperBound) <= 0);\n            }\n        }\n        \n        return false;\n    }\n    \n    return false;\n};"
          less_or_equal: "// [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3\n// [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3\n// [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2\n// [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2\n\nconst tosca = require('tosca.lib.utils');\n\nexports.validate = function(currentPropertyValue) {\n    const parsed = tosca.parseComparisonArguments(currentPropertyValue, arguments);\n    if (!parsed) {\n        return false;\n    }\n    \n    return tosca.compare(parsed.val1, parsed.val2) <= 0;\n};"
          less_than: "// [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3\n// [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3\n// [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2\n// [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2\n\nconst tosca = require('tosca.lib.utils');\n\nexports.validate = function(currentPropertyValue) {\n    const parsed = tosca.parseComparisonArguments(currentPropertyValue, arguments);\n    if (!parsed) {\n        return false;\n    }\n    \n    return tosca.compare(parsed.val1, parsed.val2) < 0;\n};"
          matches: "// [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3\n// [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3\n// [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2\n// [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2\n\n// TOSCA 2.0 operator: matches\nconst tosca = require('tosca.lib.utils');\n\nexports.validate = function(currentPropertyValue) {\n    const parsed = tosca.parseComparisonArguments(currentPropertyValue, arguments);\n    if (!parsed) {\n        return false;\n    }\n    \n    const stringToTest = parsed.val1;\n    const regexPattern = parsed.val2;\n    \n    // Validate arguments\n    if (stringToTest === undefined || stringToTest === null) {\n        return false;\n    }\n    \n    if (regexPattern === undefined || regexPattern === null) {\n        return false;\n    }\n    \n    // Both arguments must be strings\n    if (typeof stringToTest !== 'string' || typeof regexPattern !== 'string') {\n        return false;\n    }\n    \n    try {\n        const regex = new RegExp(regexPattern);\n        return regex.test(stringToTest);\n    } catch (e) {\n        // Invalid regex pattern\n        return false;\n    }\n};"
          max_length: "// [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3\n// [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3\n// [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2\n// [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2\n\nconst tosca = require('tosca.lib.utils');\n\nexports.validate = function() {\n    // Take the last 2 arguments like other constraints do\n    if (arguments.length < 2)\n        throw 'must have at least 2 arguments: value and maximum length';\n    \n    var v = arguments[arguments.length - 2];      // Second-to-last argument\n    var length = arguments[arguments.length - 1]; // Last argument\n    \n    return tosca.getLength(v) <= length;\n};"
          min_length: "// [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3\n// [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3\n// [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2\n// [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2\n\nconst tosca = require('tosca.lib.utils');\n\nexports.validate = function() {\n    // Take the last 2 arguments like other constraints do\n    if (arguments.length < 2)\n        throw 'must have at least 2 arguments: value and minimum length';\n    \n    var v = arguments[arguments.length - 2];      // Second-to-last argument\n    var length = arguments[arguments.length - 1]; // Last argument\n    \n    return tosca.getLength(v) >= length;\n};"
          not: "// TOSCA 2.0 logical operator: not\nconst tosca = require('tosca.lib.utils');\n\nexports.validate = function(currentPropertyValue) {\n    // NOT requires exactly one sub-clause\n    if (arguments.length !== 2) {\n        return false;\n    }\n\n    const subclauseArg = arguments[1];\n    \n    // Handle structured objects from parser\n    if (subclauseArg && typeof subclauseArg === 'object' && subclauseArg.Operator && subclauseArg.Arguments) {\n        // This is a structured constraint object from the parser\n        const operatorName = subclauseArg.Operator;\n        const constraintArgs = subclauseArg.Arguments || [];\n        \n        // Validate the structured subclause and return its negation\n        const isSubclauseValid = tosca.validateConstraintSubclause.call(this, operatorName, constraintArgs, currentPropertyValue);\n        \n        return !isSubclauseValid;\n    }\n    \n    // Handle simple constraint map format (legacy)\n    const subclauseMap = subclauseArg;\n    \n    // Parse the subclause\n    const parsed = tosca.parseConstraintSubclause(subclauseMap);\n    if (!parsed) {\n        return true; // Empty or malformed sub-clause -> NOT of nothing is true\n    }\n\n    const { operatorFunctionName, originalOperatorArgs } = parsed;\n\n    // Process arguments - handle complex objects but preserve simple \"$value\" strings\n    const processedArgs = [];\n    for (const arg of originalOperatorArgs) {\n        let processed;\n        if (arg === '$value') {\n            // Handle string literal \"$value\" - don't process, let individual constraints handle it\n            processed = arg;\n        } else if (typeof arg === 'object' && arg !== null && !Array.isArray(arg)) {\n            // Handle complex objects like {\"$value\":[\"count\"]} - these need processing\n            processed = tosca.evaluateConstraintArgument.call(this, arg, currentPropertyValue);\n        } else {\n            // Handle arrays and primitives - pass through\n            processed = arg;\n        }\n        processedArgs.push(processed);\n    }\n    \n    // Validate the subclause and return its negation\n    const isSubclauseValid = tosca.validateConstraintSubclause.call(this, operatorFunctionName, processedArgs, currentPropertyValue);\n    \n    return !isSubclauseValid; // Return opposite of sub-clause result\n};"
          or: "// TOSCA 2.0 logical operator: or\nconst tosca = require('tosca.lib.utils');\n\nexports.validate = function(currentPropertyValue) {\n    // Empty OR is false\n    if (arguments.length <= 1) {\n        return false;\n    }\n\n    // Process each sub-clause\n    for (let i = 1; i < arguments.length; i++) {\n        const subclauseArg = arguments[i];\n        \n        // Handle structured objects from parser\n        if (subclauseArg && typeof subclauseArg === 'object' && subclauseArg.Operator && subclauseArg.Arguments) {\n            // This is a structured constraint object from the parser\n            const operatorName = subclauseArg.Operator;\n            const constraintArgs = subclauseArg.Arguments || [];\n            \n            // Validate the structured subclause\n            const isSubclauseValid = tosca.validateConstraintSubclause.call(this, operatorName, constraintArgs, currentPropertyValue);\n            \n            if (isSubclauseValid) {\n                return true; // Short-circuit on first success\n            }\n            continue;\n        }\n        \n        // Handle simple constraint map format (legacy)\n        const subclauseMap = subclauseArg;\n        \n        // Parse the subclause\n        const parsed = tosca.parseConstraintSubclause(subclauseMap);\n        if (!parsed) {\n            continue; // Skip empty or malformed sub-clause\n        }\n\n        const { operatorFunctionName, originalOperatorArgs } = parsed;\n\n        // Process arguments - handle complex objects but preserve simple \"$value\" strings\n        const processedArgs = [];\n        for (const arg of originalOperatorArgs) {\n            let processed;\n            if (arg === '$value') {\n                // Handle string literal \"$value\" - don't process, let individual constraints handle it\n                processed = arg;\n            } else if (typeof arg === 'object' && arg !== null && !Array.isArray(arg)) {\n                // Handle complex objects like {\"$value\":[\"count\"]} - these need processing\n                processed = tosca.evaluateConstraintArgument.call(this, arg, currentPropertyValue);\n            } else {\n                // Handle arrays and primitives - pass through\n                processed = arg;\n            }\n            processedArgs.push(processed);\n        }\n        \n        // Validate the subclause\n        const isSubclauseValid = tosca.validateConstraintSubclause.call(this, operatorFunctionName, processedArgs, currentPropertyValue);\n        \n        if (isSubclauseValid) {\n            return true; // Short-circuit on first success\n        }\n    }\n\n    return false; // All clauses failed\n};"
          pattern: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2

            exports.validate = function(v, re) {
              if (arguments.length !== 2)
                throw 'must have 1 argument';
              if (v.$string !== undefined)
                v = v.$string;
              return new RegExp('^' + re + '$').test(v);
            };
          schema: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3

            exports.validate = function() {
              // TODO
              return true;
            };
          valid_values: "// [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3\n// [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3\n// [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2\n// [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2\n\n// TOSCA 2.0 operator: valid_values\nconst tosca = require('tosca.lib.utils');\n\nexports.validate = function(currentPropertyValue) {\n    if (arguments.length === 3) {\n        // TOSCA 2.0 syntax: $valid_values: [ <value_to_test>, <list_of_valid_values> ]\n        // Called as: valid_values(currentPropertyValue, valueToTest, validValuesArray)\n        let valueToTest = arguments[1];\n        const validValuesArray = arguments[2];\n        \n        // Handle \"$value\" substitution\n        if (valueToTest === '$value') {\n            valueToTest = currentPropertyValue;\n        }\n        \n        if (!Array.isArray(validValuesArray)) {\n            // Fallback: if third argument is not an array, treat all arguments from 1 onwards as valid values\n            const validValuesArrayFromArgs = Array.prototype.slice.call(arguments, 1);\n            return exports.checkValueInList(currentPropertyValue, validValuesArrayFromArgs);\n        }\n        \n        return exports.checkValueInList(valueToTest, validValuesArray);\n        \n    } else if (arguments.length === 2) {\n        // Legacy syntax: $valid_values: <list_of_valid_values>\n        // Called as: valid_values(currentPropertyValue, validValuesArray)\n        const validValuesArray = arguments[1];\n        \n        if (!Array.isArray(validValuesArray)) {\n            return false;\n        }\n        \n        return exports.checkValueInList(currentPropertyValue, validValuesArray);\n        \n    } else if (arguments.length > 3) {\n        // Alternative: $valid_values: [ val1, val2, val3, ... ]\n        // Called as: valid_values(currentPropertyValue, val1, val2, val3, ...)\n        const validValuesArray = Array.prototype.slice.call(arguments, 1);\n        return exports.checkValueInList(currentPropertyValue, validValuesArray);\n        \n    } else {\n        return false;\n    }\n};\n\n// Helper function to check if a value is in a list, with scalar parsing support\nexports.checkValueInList = function(valueToTest, validValuesArray) {\n    for (const validValue of validValuesArray) {\n        if (exports.compareValues(valueToTest, validValue)) {\n            return true;\n        }\n    }\n    return false;\n};\n\n// Enhanced comparison that handles scalar parsing\nexports.compareValues = function(val1, val2) {\n    // If both are scalar objects, use canonical comparison\n    if (val1 && val1.$number !== undefined && val2 && val2.$number !== undefined) {\n        return tosca.compare(val1, val2) === 0;\n    }\n    \n    // If val1 is scalar and val2 is string, try to parse val2 as scalar\n    if (val1 && val1.$number !== undefined && typeof val2 === 'string') {\n        const parsedVal2 = tosca.tryParseScalar(val2, val1);\n        if (parsedVal2) {\n            return tosca.compare(val1, parsedVal2) === 0;\n        }\n    }\n    \n    // If val2 is scalar and val1 is string, try to parse val1 as scalar\n    if (val2 && val2.$number !== undefined && typeof val1 === 'string') {\n        const parsedVal1 = tosca.tryParseScalar(val1, val2);\n        if (parsedVal1) {\n            return tosca.compare(parsedVal1, val2) === 0;\n        }\n    }\n    \n    // Fallback to standard comparison\n    const comparable1 = tosca.getComparable(val1);\n    const comparable2 = tosca.getComparable(val2);\n    return comparable1 === comparable2;\n};"
          xor: "// TOSCA 2.0 logical operator: xor\nconst tosca = require('tosca.lib.utils');\n\nexports.validate = function(currentPropertyValue) {\n    // XOR is true if exactly one sub-clause is true\n    if (arguments.length <= 1) {\n        return false;\n    }\n\n    let trueCount = 0;\n\n    // Process each sub-clause\n    for (let i = 1; i < arguments.length; i++) {\n        const subclauseArg = arguments[i];\n        \n        // Handle structured objects from parser\n        if (subclauseArg && typeof subclauseArg === 'object' && subclauseArg.Operator && subclauseArg.Arguments) {\n            // This is a structured constraint object from the parser\n            const operatorName = subclauseArg.Operator;\n            const constraintArgs = subclauseArg.Arguments || [];\n            \n            // Validate the structured subclause\n            const isSubclauseValid = tosca.validateConstraintSubclause.call(this, operatorName, constraintArgs, currentPropertyValue);\n            \n            if (isSubclauseValid) {\n                trueCount++;\n            }\n            continue;\n        }\n        \n        // Handle simple constraint map format (legacy)\n        const subclauseMap = subclauseArg;\n        \n        // Parse the subclause\n        const parsed = tosca.parseConstraintSubclause(subclauseMap);\n        if (!parsed) {\n            continue; // Skip empty or malformed sub-clause\n        }\n\n        const { operatorFunctionName, originalOperatorArgs } = parsed;\n\n        // Process arguments - handle complex objects but preserve simple \"$value\" strings\n        const processedArgs = [];\n        for (const arg of originalOperatorArgs) {\n            let processed;\n            if (arg === '$value') {\n                // Handle string literal \"$value\" - don't process, let individual constraints handle it\n                processed = arg;\n            } else if (typeof arg === 'object' && arg !== null && !Array.isArray(arg)) {\n                // Handle complex objects like {\"$value\":[\"count\"]} - these need processing\n                processed = tosca.evaluateConstraintArgument.call(this, arg, currentPropertyValue);\n            } else {\n                // Handle arrays and primitives - pass through\n                processed = arg;\n            }\n            processedArgs.push(processed);\n        }\n        \n        // Validate the subclause\n        const isSubclauseValid = tosca.validateConstraintSubclause.call(this, operatorFunctionName, processedArgs, currentPropertyValue);\n        \n        if (isSubclauseValid) {\n            trueCount++;\n        }\n    }\n\n    return trueCount === 1; // XOR succeeds if exactly one clause is true\n};"
    version: "1.0"
properties:
  tosca:
    description: ""
    inputs:
      async_timeout: 30
      polling_interval: 5
      target_hosts: all
    metadata:
      description: Service template for asynchronous operations with file management
      template_author: DevOps Engineer
      template_name: Async Operations Service
    outputs:
      environment_directory: ~/.ansible_async
      operations_summary:
        - operation:
            $get_property:
              - polling_sleep_operation
              - operation_name
          status:
            $get_attribute:
              - polling_sleep_operation
              - operation_status
        - operation:
            $get_property:
              - file_create_operation
              - operation_name
          status:
            $get_attribute:
              - file_create_operation
              - operation_status
          target:
            $get_property:
              - file_create_operation
              - target_file
        - operation:
            $get_property:
              - file_delete_operation
              - operation_name
          status:
            $get_attribute:
              - file_delete_operation
              - operation_status
          target:
            $get_property:
              - file_delete_operation
              - target_file
      service_status: null
vertexes:
  _2zumcheZBUQ13QL4vf21kPX0S9s:
    metadata:
      puccini:
        kind: WorkflowStep
        version: "1.0"
    properties:
      name: monitor_file_creation
    edgesOut:
      - metadata:
          puccini:
            kind: NodeTemplateTarget
            version: "1.0"
        properties: {}
        targetID: _2zumciiXOYE6FFF768OuO9VZ9Aq
      - metadata:
          puccini:
            kind: WorkflowActivity
            version: "1.0"
        properties:
          sequence: 0
        targetID: _2zumcndOCYM710kQdsEd053UF1E
      - metadata:
          puccini:
            kind: WorkflowActivity
            version: "1.0"
        properties:
          sequence: 1
        targetID: _2zumciq9v1xQVEMtcRPwcWnDTPn
  _2zumchgoE6HuFrewBOZYIskeguZ:
    metadata:
      puccini:
        kind: WorkflowStep
        version: "1.0"
    properties:
      name: start_file_creation
    edgesOut:
      - metadata:
          puccini:
            kind: NodeTemplateTarget
            version: "1.0"
        properties: {}
        targetID: _2zumci6nl09pZfPVLsImoU61q1a
      - metadata:
          puccini:
            kind: WorkflowActivity
            version: "1.0"
        properties:
          sequence: 0
        targetID: _2zumchsEW9ybu3OYumiqROOfwU1
      - metadata:
          puccini:
            kind: OnSuccess
            version: "1.0"
        properties: {}
        targetID: _2zumcmOKt8rxxEJDnGulIQUGDMz
      - metadata:
          puccini:
            kind: OnSuccess
            version: "1.0"
        properties: {}
        targetID: _2zumcheZBUQ13QL4vf21kPX0S9s
  _2zumchsEW9ybu3OYumiqROOfwU1:
    metadata:
      puccini:
        kind: WorkflowActivity
        version: "1.0"
    properties: {}
    edgesOut: []
  _2zumchwTA5SNEMUCEVdPQcXEpUt:
    metadata:
      puccini:
        kind: WorkflowStep
        version: "1.0"
    properties:
      name: monitor_file_deletion
    edgesOut:
      - metadata:
          puccini:
            kind: NodeTemplateTarget
            version: "1.0"
        properties: {}
        targetID: _2zumclcE9oMGf4cUW8uw9KalThO
      - metadata:
          puccini:
            kind: WorkflowActivity
            version: "1.0"
        properties:
          sequence: 0
        targetID: _2zumck5I7Q5eCLVAKJ641s3jGHl
      - metadata:
          puccini:
            kind: WorkflowActivity
            version: "1.0"
        properties:
          sequence: 1
        targetID: _2zumcmNoCy9EV0XQaRd3jBa0ABV
  _2zumchxe3JpZn9UnfjrutcQJRhr:
    metadata:
      puccini:
        kind: NodeTemplate
        version: "1.0"
    properties:
      artifacts: {}
      attributes:
        state: null
      capabilities:
        feature:
          attributes: {}
          description: ""
          location:
            column: 5
            path: service_template.node_templates["debug_checkpoint_1"].capabilities["feature"]
            row: 247
          maxRelationshipCount: -1
          minRelationshipCount: 0
          properties: {}
          types:
            org.oasis-open.simple:2.0::Node:
              description: The Node capability indicates the base capabilities of a TOSCA Node Type.
      description: ""
      directives: []
      interfaces:
        Monitoring:
          description: Interface for monitoring and debugging
          inputs: {}
          metadata: {}
          notifications: {}
          operations:
            display_debug:
              dependencies: []
              description: Display debug information
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            log_status:
              dependencies: []
              description: Log operation status
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
          types:
            MonitoringInterface:
              description: Interface for monitoring and debugging
        Standard:
          description: The Standard lifecycle interface defines the essential normative operations that TOSCA nodes may support.
          inputs: {}
          metadata: {}
          notifications: {}
          operations:
            configure:
              dependencies: []
              description: Standard lifecycle configure operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            create:
              dependencies: []
              description: Standard lifecycle create operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            delete:
              dependencies: []
              description: Standard lifecycle delete operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            modify:
              dependencies: []
              description: Standard lifecycle modify operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            start:
              dependencies: []
              description: Start monitoring
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            stop:
              dependencies: []
              description: Standard lifecycle stop operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
          types:
            org.oasis-open.simple:2.0::Lifecycle.Standard:
              description: The Standard lifecycle interface defines the essential normative operations that TOSCA nodes may support.
      metadata: {}
      name: debug_checkpoint_1
      properties:
        debug_messages:
          - I'm a debug message.
        monitoring_enabled: true
      requirements:
        - capabilityName: ""
          capabilityPropertyValidators: {}
          capabilityTypeName: org.oasis-open.simple:2.0::Node
          directives: []
          location:
            column: 23
            path: service_template.node_templates["debug_checkpoint_1"].requirements{0}
            row: 252
          name: dependency
          nodeTemplateName: polling_sleep_operation
          nodeTemplatePropertyValidators: {}
          nodeTypeName: org.oasis-open.simple:2.0::Root
          optional: false
          relationship:
            attributes: {}
            description: ""
            interfaces:
              Configure:
                description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
                inputs: {}
                metadata: {}
                notifications: {}
                operations:
                  add_source:
                    dependencies: []
                    description: Operation to notify the target node of a source node which is now available via a relationship.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  add_target:
                    dependencies: []
                    description: Operation to notify the source node of a target node being added via a relationship.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  post_configure_source:
                    dependencies: []
                    description: Operation to post-configure the source endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  post_configure_target:
                    dependencies: []
                    description: Operation to post-configure the target endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  pre_configure_source:
                    dependencies: []
                    description: Operation to pre-configure the source endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  pre_configure_target:
                    dependencies: []
                    description: Operation to pre-configure the target endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  remove_target:
                    dependencies: []
                    description: Operation to remove a target node.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  target_changed:
                    dependencies: []
                    description: Operation to notify the source node that some property or attribute of the target node changed.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                types:
                  org.oasis-open.simple:2.0::Relationship.Configure:
                    description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
            metadata: {}
            properties: {}
            types:
              org.oasis-open.simple:2.0::DependsOn:
                description: The DependsOn type represents a general dependency relationship between two nodes.
                parent: org.oasis-open.simple:2.0::Root
              org.oasis-open.simple:2.0::Root:
                description: |
                  The TOSCA base relationship type from which all other normative TOSCA relationship types derive.
      types:
        OperationMonitor:
          description: Monitoring and debugging component
          parent: org.oasis-open.simple:2.0::SoftwareComponent
        org.oasis-open.simple:2.0::Root:
          description: |
            The TOSCA base node type from which all other TOSCA normative node types derive.
        org.oasis-open.simple:2.0::SoftwareComponent:
          description: |
            The TOSCA SoftwareComponent node represents a generic software component that can be managed and run by a TOSCA compute node.
          parent: org.oasis-open.simple:2.0::Root
    edgesOut:
      - metadata:
          puccini:
            kind: Relationship
            version: "1.0"
        properties:
          attributes: {}
          capability: feature
          description: ""
          interfaces:
            Configure:
              description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
              inputs: {}
              metadata: {}
              notifications: {}
              operations:
                add_source:
                  dependencies: []
                  description: Operation to notify the target node of a source node which is now available via a relationship.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                add_target:
                  dependencies: []
                  description: Operation to notify the source node of a target node being added via a relationship.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                post_configure_source:
                  dependencies: []
                  description: Operation to post-configure the source endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                post_configure_target:
                  dependencies: []
                  description: Operation to post-configure the target endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                pre_configure_source:
                  dependencies: []
                  description: Operation to pre-configure the source endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                pre_configure_target:
                  dependencies: []
                  description: Operation to pre-configure the target endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                remove_target:
                  dependencies: []
                  description: Operation to remove a target node.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                target_changed:
                  dependencies: []
                  description: Operation to notify the source node that some property or attribute of the target node changed.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
              types:
                org.oasis-open.simple:2.0::Relationship.Configure:
                  description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
          name: dependency
          properties: {}
          types:
            org.oasis-open.simple:2.0::DependsOn:
              description: The DependsOn type represents a general dependency relationship between two nodes.
              parent: org.oasis-open.simple:2.0::Root
            org.oasis-open.simple:2.0::Root:
              description: |
                The TOSCA base relationship type from which all other normative TOSCA relationship types derive.
        targetID: _2zumcmh1CzwGLyFbe6pj4MwFOr2
  _2zumci6nl09pZfPVLsImoU61q1a:
    metadata:
      puccini:
        kind: NodeTemplate
        version: "1.0"
    properties:
      artifacts: {}
      attributes:
        execution_time: null
        job_id: null
        operation_status: null
        state: null
      capabilities:
        feature:
          attributes: {}
          description: ""
          location:
            column: 5
            path: service_template.node_templates["file_create_operation"].capabilities["feature"]
            row: 255
          maxRelationshipCount: -1
          minRelationshipCount: 0
          properties: {}
          types:
            org.oasis-open.simple:2.0::Node:
              description: The Node capability indicates the base capabilities of a TOSCA Node Type.
      description: ""
      directives: []
      interfaces:
        AsyncManagement:
          description: Interface for managing asynchronous operations
          inputs: {}
          metadata: {}
          notifications: {}
          operations:
            check_status:
              dependencies: []
              description: Check operation status
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            execute_async:
              dependencies: []
              description: Execute operation asynchronously
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            wait_completion:
              dependencies: []
              description: Wait for operation completion
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
          types:
            AsyncManagementInterface:
              description: Interface for managing asynchronous operations
        Standard:
          description: The Standard lifecycle interface defines the essential normative operations that TOSCA nodes may support.
          inputs: {}
          metadata: {}
          notifications: {}
          operations:
            configure:
              dependencies: []
              description: Standard lifecycle configure operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            create:
              dependencies: []
              description: Standard lifecycle create operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            delete:
              dependencies: []
              description: Standard lifecycle delete operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            modify:
              dependencies: []
              description: Standard lifecycle modify operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            start:
              dependencies: []
              description: Start the async operation
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            stop:
              dependencies: []
              description: Stop the async operation
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
          types:
            org.oasis-open.simple:2.0::Lifecycle.Standard:
              description: The Standard lifecycle interface defines the essential normative operations that TOSCA nodes may support.
      metadata: {}
      name: file_create_operation
      properties:
        delay_before_execution: 15
        fire_and_forget: true
        operation_name: create_test_file
        operation_type: create
        polling_interval: 5
        retry_attempts: 20
        target_file: /tmp/test_file
        timeout_seconds: 30
      requirements:
        - capabilityName: ""
          capabilityPropertyValidators: {}
          capabilityTypeName: org.oasis-open.simple:2.0::Node
          directives: []
          location:
            column: 23
            path: service_template.node_templates["file_create_operation"].requirements{0}
            row: 266
          name: dependency
          nodeTemplateName: debug_checkpoint_1
          nodeTemplatePropertyValidators: {}
          nodeTypeName: org.oasis-open.simple:2.0::Root
          optional: false
          relationship:
            attributes: {}
            description: ""
            interfaces:
              Configure:
                description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
                inputs: {}
                metadata: {}
                notifications: {}
                operations:
                  add_source:
                    dependencies: []
                    description: Operation to notify the target node of a source node which is now available via a relationship.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  add_target:
                    dependencies: []
                    description: Operation to notify the source node of a target node being added via a relationship.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  post_configure_source:
                    dependencies: []
                    description: Operation to post-configure the source endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  post_configure_target:
                    dependencies: []
                    description: Operation to post-configure the target endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  pre_configure_source:
                    dependencies: []
                    description: Operation to pre-configure the source endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  pre_configure_target:
                    dependencies: []
                    description: Operation to pre-configure the target endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  remove_target:
                    dependencies: []
                    description: Operation to remove a target node.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  target_changed:
                    dependencies: []
                    description: Operation to notify the source node that some property or attribute of the target node changed.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                types:
                  org.oasis-open.simple:2.0::Relationship.Configure:
                    description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
            metadata: {}
            properties: {}
            types:
              org.oasis-open.simple:2.0::DependsOn:
                description: The DependsOn type represents a general dependency relationship between two nodes.
                parent: org.oasis-open.simple:2.0::Root
              org.oasis-open.simple:2.0::Root:
                description: |
                  The TOSCA base relationship type from which all other normative TOSCA relationship types derive.
      types:
        AsyncOperation:
          description: Abstract long-running operation
          parent: org.oasis-open.simple:2.0::SoftwareComponent
        FileOperation:
          description: File system operation
          parent: AsyncOperation
        org.oasis-open.simple:2.0::Root:
          description: |
            The TOSCA base node type from which all other TOSCA normative node types derive.
        org.oasis-open.simple:2.0::SoftwareComponent:
          description: |
            The TOSCA SoftwareComponent node represents a generic software component that can be managed and run by a TOSCA compute node.
          parent: org.oasis-open.simple:2.0::Root
    edgesOut:
      - metadata:
          puccini:
            kind: Relationship
            version: "1.0"
        properties:
          attributes: {}
          capability: feature
          description: ""
          interfaces:
            Configure:
              description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
              inputs: {}
              metadata: {}
              notifications: {}
              operations:
                add_source:
                  dependencies: []
                  description: Operation to notify the target node of a source node which is now available via a relationship.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                add_target:
                  dependencies: []
                  description: Operation to notify the source node of a target node being added via a relationship.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                post_configure_source:
                  dependencies: []
                  description: Operation to post-configure the source endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                post_configure_target:
                  dependencies: []
                  description: Operation to post-configure the target endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                pre_configure_source:
                  dependencies: []
                  description: Operation to pre-configure the source endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                pre_configure_target:
                  dependencies: []
                  description: Operation to pre-configure the target endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                remove_target:
                  dependencies: []
                  description: Operation to remove a target node.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                target_changed:
                  dependencies: []
                  description: Operation to notify the source node that some property or attribute of the target node changed.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
              types:
                org.oasis-open.simple:2.0::Relationship.Configure:
                  description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
          name: dependency
          properties: {}
          types:
            org.oasis-open.simple:2.0::DependsOn:
              description: The DependsOn type represents a general dependency relationship between two nodes.
              parent: org.oasis-open.simple:2.0::Root
            org.oasis-open.simple:2.0::Root:
              description: |
                The TOSCA base relationship type from which all other normative TOSCA relationship types derive.
        targetID: _2zumchxe3JpZn9UnfjrutcQJRhr
  _2zumci7OypXFKPHzTVVhsEOXpQY:
    metadata:
      puccini:
        kind: WorkflowActivity
        version: "1.0"
    properties: {}
    edgesOut: []
  _2zumciiXOYE6FFF768OuO9VZ9Aq:
    metadata:
      puccini:
        kind: NodeTemplate
        version: "1.0"
    properties:
      artifacts: {}
      attributes:
        execution_time: null
        job_id: null
        operation_status: null
        state: null
      capabilities:
        feature:
          attributes: {}
          description: ""
          location:
            column: 5
            path: service_template.node_templates["file_create_monitor"].capabilities["feature"]
            row: 277
          maxRelationshipCount: -1
          minRelationshipCount: 0
          properties: {}
          types:
            org.oasis-open.simple:2.0::Node:
              description: The Node capability indicates the base capabilities of a TOSCA Node Type.
      description: ""
      directives: []
      interfaces:
        AsyncManagement:
          description: Interface for managing asynchronous operations
          inputs: {}
          metadata: {}
          notifications: {}
          operations:
            check_status:
              dependencies: []
              description: Check operation status
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            execute_async:
              dependencies: []
              description: Execute operation asynchronously
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            wait_completion:
              dependencies: []
              description: Wait for operation completion
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
          types:
            AsyncManagementInterface:
              description: Interface for managing asynchronous operations
        Standard:
          description: The Standard lifecycle interface defines the essential normative operations that TOSCA nodes may support.
          inputs: {}
          metadata: {}
          notifications: {}
          operations:
            configure:
              dependencies: []
              description: Standard lifecycle configure operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            create:
              dependencies: []
              description: Standard lifecycle create operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            delete:
              dependencies: []
              description: Standard lifecycle delete operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            modify:
              dependencies: []
              description: Standard lifecycle modify operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            start:
              dependencies: []
              description: Start the async operation
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            stop:
              dependencies: []
              description: Stop the async operation
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
          types:
            org.oasis-open.simple:2.0::Lifecycle.Standard:
              description: The Standard lifecycle interface defines the essential normative operations that TOSCA nodes may support.
      metadata: {}
      name: file_create_monitor
      properties:
        fire_and_forget: false
        operation_name: monitor_file_creation
        polling_interval: 5
        retry_attempts: 20
        timeout_seconds: 30
      requirements:
        - capabilityName: ""
          capabilityPropertyValidators: {}
          capabilityTypeName: org.oasis-open.simple:2.0::Node
          directives: []
          location:
            column: 23
            path: service_template.node_templates["file_create_monitor"].requirements{0}
            row: 284
          name: dependency
          nodeTemplateName: file_create_operation
          nodeTemplatePropertyValidators: {}
          nodeTypeName: org.oasis-open.simple:2.0::Root
          optional: false
          relationship:
            attributes: {}
            description: ""
            interfaces:
              Configure:
                description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
                inputs: {}
                metadata: {}
                notifications: {}
                operations:
                  add_source:
                    dependencies: []
                    description: Operation to notify the target node of a source node which is now available via a relationship.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  add_target:
                    dependencies: []
                    description: Operation to notify the source node of a target node being added via a relationship.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  post_configure_source:
                    dependencies: []
                    description: Operation to post-configure the source endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  post_configure_target:
                    dependencies: []
                    description: Operation to post-configure the target endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  pre_configure_source:
                    dependencies: []
                    description: Operation to pre-configure the source endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  pre_configure_target:
                    dependencies: []
                    description: Operation to pre-configure the target endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  remove_target:
                    dependencies: []
                    description: Operation to remove a target node.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  target_changed:
                    dependencies: []
                    description: Operation to notify the source node that some property or attribute of the target node changed.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                types:
                  org.oasis-open.simple:2.0::Relationship.Configure:
                    description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
            metadata: {}
            properties: {}
            types:
              org.oasis-open.simple:2.0::DependsOn:
                description: The DependsOn type represents a general dependency relationship between two nodes.
                parent: org.oasis-open.simple:2.0::Root
              org.oasis-open.simple:2.0::Root:
                description: |
                  The TOSCA base relationship type from which all other normative TOSCA relationship types derive.
      types:
        AsyncOperation:
          description: Abstract long-running operation
          parent: org.oasis-open.simple:2.0::SoftwareComponent
        org.oasis-open.simple:2.0::Root:
          description: |
            The TOSCA base node type from which all other TOSCA normative node types derive.
        org.oasis-open.simple:2.0::SoftwareComponent:
          description: |
            The TOSCA SoftwareComponent node represents a generic software component that can be managed and run by a TOSCA compute node.
          parent: org.oasis-open.simple:2.0::Root
    edgesOut:
      - metadata:
          puccini:
            kind: Relationship
            version: "1.0"
        properties:
          attributes: {}
          capability: feature
          description: ""
          interfaces:
            Configure:
              description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
              inputs: {}
              metadata: {}
              notifications: {}
              operations:
                add_source:
                  dependencies: []
                  description: Operation to notify the target node of a source node which is now available via a relationship.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                add_target:
                  dependencies: []
                  description: Operation to notify the source node of a target node being added via a relationship.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                post_configure_source:
                  dependencies: []
                  description: Operation to post-configure the source endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                post_configure_target:
                  dependencies: []
                  description: Operation to post-configure the target endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                pre_configure_source:
                  dependencies: []
                  description: Operation to pre-configure the source endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                pre_configure_target:
                  dependencies: []
                  description: Operation to pre-configure the target endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                remove_target:
                  dependencies: []
                  description: Operation to remove a target node.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                target_changed:
                  dependencies: []
                  description: Operation to notify the source node that some property or attribute of the target node changed.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
              types:
                org.oasis-open.simple:2.0::Relationship.Configure:
                  description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
          name: dependency
          properties: {}
          types:
            org.oasis-open.simple:2.0::DependsOn:
              description: The DependsOn type represents a general dependency relationship between two nodes.
              parent: org.oasis-open.simple:2.0::Root
            org.oasis-open.simple:2.0::Root:
              description: |
                The TOSCA base relationship type from which all other normative TOSCA relationship types derive.
        targetID: _2zumci6nl09pZfPVLsImoU61q1a
  _2zumciq9v1xQVEMtcRPwcWnDTPn:
    metadata:
      puccini:
        kind: WorkflowActivity
        version: "1.0"
    properties: {}
    edgesOut: []
  _2zumcjHQTNa4wuXDNpSSTCT5xnN:
    metadata:
      puccini:
        kind: NodeTemplate
        version: "1.0"
    properties:
      artifacts: {}
      attributes:
        state: null
      capabilities:
        feature:
          attributes: {}
          description: ""
          location:
            column: 5
            path: service_template.node_templates["debug_checkpoint_2"].capabilities["feature"]
            row: 269
          maxRelationshipCount: -1
          minRelationshipCount: 0
          properties: {}
          types:
            org.oasis-open.simple:2.0::Node:
              description: The Node capability indicates the base capabilities of a TOSCA Node Type.
      description: ""
      directives: []
      interfaces:
        Monitoring:
          description: Interface for monitoring and debugging
          inputs: {}
          metadata: {}
          notifications: {}
          operations:
            display_debug:
              dependencies: []
              description: Display debug information
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            log_status:
              dependencies: []
              description: Log operation status
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
          types:
            MonitoringInterface:
              description: Interface for monitoring and debugging
        Standard:
          description: The Standard lifecycle interface defines the essential normative operations that TOSCA nodes may support.
          inputs: {}
          metadata: {}
          notifications: {}
          operations:
            configure:
              dependencies: []
              description: Standard lifecycle configure operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            create:
              dependencies: []
              description: Standard lifecycle create operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            delete:
              dependencies: []
              description: Standard lifecycle delete operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            modify:
              dependencies: []
              description: Standard lifecycle modify operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            start:
              dependencies: []
              description: Start monitoring
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            stop:
              dependencies: []
              description: Standard lifecycle stop operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
          types:
            org.oasis-open.simple:2.0::Lifecycle.Standard:
              description: The Standard lifecycle interface defines the essential normative operations that TOSCA nodes may support.
      metadata: {}
      name: debug_checkpoint_2
      properties:
        debug_messages:
          - I'm another debug message.
        monitoring_enabled: true
      requirements:
        - capabilityName: ""
          capabilityPropertyValidators: {}
          capabilityTypeName: org.oasis-open.simple:2.0::Node
          directives: []
          location:
            column: 23
            path: service_template.node_templates["debug_checkpoint_2"].requirements{0}
            row: 274
          name: dependency
          nodeTemplateName: file_create_operation
          nodeTemplatePropertyValidators: {}
          nodeTypeName: org.oasis-open.simple:2.0::Root
          optional: false
          relationship:
            attributes: {}
            description: ""
            interfaces:
              Configure:
                description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
                inputs: {}
                metadata: {}
                notifications: {}
                operations:
                  add_source:
                    dependencies: []
                    description: Operation to notify the target node of a source node which is now available via a relationship.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  add_target:
                    dependencies: []
                    description: Operation to notify the source node of a target node being added via a relationship.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  post_configure_source:
                    dependencies: []
                    description: Operation to post-configure the source endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  post_configure_target:
                    dependencies: []
                    description: Operation to post-configure the target endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  pre_configure_source:
                    dependencies: []
                    description: Operation to pre-configure the source endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  pre_configure_target:
                    dependencies: []
                    description: Operation to pre-configure the target endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  remove_target:
                    dependencies: []
                    description: Operation to remove a target node.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  target_changed:
                    dependencies: []
                    description: Operation to notify the source node that some property or attribute of the target node changed.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                types:
                  org.oasis-open.simple:2.0::Relationship.Configure:
                    description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
            metadata: {}
            properties: {}
            types:
              org.oasis-open.simple:2.0::DependsOn:
                description: The DependsOn type represents a general dependency relationship between two nodes.
                parent: org.oasis-open.simple:2.0::Root
              org.oasis-open.simple:2.0::Root:
                description: |
                  The TOSCA base relationship type from which all other normative TOSCA relationship types derive.
      types:
        OperationMonitor:
          description: Monitoring and debugging component
          parent: org.oasis-open.simple:2.0::SoftwareComponent
        org.oasis-open.simple:2.0::Root:
          description: |
            The TOSCA base node type from which all other TOSCA normative node types derive.
        org.oasis-open.simple:2.0::SoftwareComponent:
          description: |
            The TOSCA SoftwareComponent node represents a generic software component that can be managed and run by a TOSCA compute node.
          parent: org.oasis-open.simple:2.0::Root
    edgesOut:
      - metadata:
          puccini:
            kind: Relationship
            version: "1.0"
        properties:
          attributes: {}
          capability: feature
          description: ""
          interfaces:
            Configure:
              description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
              inputs: {}
              metadata: {}
              notifications: {}
              operations:
                add_source:
                  dependencies: []
                  description: Operation to notify the target node of a source node which is now available via a relationship.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                add_target:
                  dependencies: []
                  description: Operation to notify the source node of a target node being added via a relationship.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                post_configure_source:
                  dependencies: []
                  description: Operation to post-configure the source endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                post_configure_target:
                  dependencies: []
                  description: Operation to post-configure the target endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                pre_configure_source:
                  dependencies: []
                  description: Operation to pre-configure the source endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                pre_configure_target:
                  dependencies: []
                  description: Operation to pre-configure the target endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                remove_target:
                  dependencies: []
                  description: Operation to remove a target node.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                target_changed:
                  dependencies: []
                  description: Operation to notify the source node that some property or attribute of the target node changed.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
              types:
                org.oasis-open.simple:2.0::Relationship.Configure:
                  description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
          name: dependency
          properties: {}
          types:
            org.oasis-open.simple:2.0::DependsOn:
              description: The DependsOn type represents a general dependency relationship between two nodes.
              parent: org.oasis-open.simple:2.0::Root
            org.oasis-open.simple:2.0::Root:
              description: |
                The TOSCA base relationship type from which all other normative TOSCA relationship types derive.
        targetID: _2zumci6nl09pZfPVLsImoU61q1a
  _2zumcjxd7mpibG2HWQDFJ6kKGCw:
    metadata:
      puccini:
        kind: Workflow
        version: "1.0"
    properties:
      description: Orchestrates the sequence of async operations
      name: async_operations_workflow
    edgesOut:
      - metadata:
          puccini:
            kind: WorkflowStep
            version: "1.0"
        properties: {}
        targetID: _2zumcnHle3iu8SIDi3nsVHg1tDb
      - metadata:
          puccini:
            kind: WorkflowStep
            version: "1.0"
        properties: {}
        targetID: _2zumcncC4wQYxdXI96hr9yboIyW
      - metadata:
          puccini:
            kind: WorkflowStep
            version: "1.0"
        properties: {}
        targetID: _2zumcmOKt8rxxEJDnGulIQUGDMz
      - metadata:
          puccini:
            kind: WorkflowStep
            version: "1.0"
        properties: {}
        targetID: _2zumchwTA5SNEMUCEVdPQcXEpUt
      - metadata:
          puccini:
            kind: WorkflowStep
            version: "1.0"
        properties: {}
        targetID: _2zumckHoKAjGA1gJ9WIZmJ14NiT
      - metadata:
          puccini:
            kind: WorkflowStep
            version: "1.0"
        properties: {}
        targetID: _2zumcheZBUQ13QL4vf21kPX0S9s
      - metadata:
          puccini:
            kind: WorkflowStep
            version: "1.0"
        properties: {}
        targetID: _2zumchgoE6HuFrewBOZYIskeguZ
      - metadata:
          puccini:
            kind: WorkflowStep
            version: "1.0"
        properties: {}
        targetID: _2zumcnmFNW8REjiGE4jGKuXHWOo
      - metadata:
          puccini:
            kind: WorkflowStep
            version: "1.0"
        properties: {}
        targetID: _2zumcmJgFcice5PaFPtkB9AOpk4
  _2zumck5I7Q5eCLVAKJ641s3jGHl:
    metadata:
      puccini:
        kind: WorkflowActivity
        version: "1.0"
    properties: {}
    edgesOut: []
  _2zumckHoKAjGA1gJ9WIZmJ14NiT:
    metadata:
      puccini:
        kind: WorkflowStep
        version: "1.0"
    properties:
      name: display_debug_1
    edgesOut:
      - metadata:
          puccini:
            kind: NodeTemplateTarget
            version: "1.0"
        properties: {}
        targetID: _2zumchxe3JpZn9UnfjrutcQJRhr
      - metadata:
          puccini:
            kind: WorkflowActivity
            version: "1.0"
        properties:
          sequence: 0
        targetID: _2zumckO3w8Y33JpwT6dV7LaSWYd
      - metadata:
          puccini:
            kind: OnSuccess
            version: "1.0"
        properties: {}
        targetID: _2zumchgoE6HuFrewBOZYIskeguZ
  _2zumckO3w8Y33JpwT6dV7LaSWYd:
    metadata:
      puccini:
        kind: WorkflowActivity
        version: "1.0"
    properties: {}
    edgesOut: []
  _2zumckOwdW6e2fvmPD9KoSMcbnh:
    metadata:
      puccini:
        kind: WorkflowActivity
        version: "1.0"
    properties: {}
    edgesOut: []
  _2zumckU1sXTZtMO024HaorQDt02:
    metadata:
      puccini:
        kind: WorkflowActivity
        version: "1.0"
    properties: {}
    edgesOut: []
  _2zumcklWBqMFfQwFWg7cW7BLPgq:
    metadata:
      puccini:
        kind: NodeTemplate
        version: "1.0"
    properties:
      artifacts: {}
      attributes:
        state: null
      capabilities:
        feature:
          attributes: {}
          description: ""
          location:
            column: 5
            path: service_template.node_templates["operation_monitor"].capabilities["feature"]
            row: 226
          maxRelationshipCount: -1
          minRelationshipCount: 0
          properties: {}
          types:
            org.oasis-open.simple:2.0::Node:
              description: The Node capability indicates the base capabilities of a TOSCA Node Type.
      description: ""
      directives: []
      interfaces:
        Monitoring:
          description: Interface for monitoring and debugging
          inputs: {}
          metadata: {}
          notifications: {}
          operations:
            display_debug:
              dependencies: []
              description: Display debug information
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            log_status:
              dependencies: []
              description: Log operation status
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
          types:
            MonitoringInterface:
              description: Interface for monitoring and debugging
        Standard:
          description: The Standard lifecycle interface defines the essential normative operations that TOSCA nodes may support.
          inputs: {}
          metadata: {}
          notifications: {}
          operations:
            configure:
              dependencies: []
              description: Standard lifecycle configure operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            create:
              dependencies: []
              description: Standard lifecycle create operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            delete:
              dependencies: []
              description: Standard lifecycle delete operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            modify:
              dependencies: []
              description: Standard lifecycle modify operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            start:
              dependencies: []
              description: Start monitoring
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            stop:
              dependencies: []
              description: Standard lifecycle stop operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
          types:
            org.oasis-open.simple:2.0::Lifecycle.Standard:
              description: The Standard lifecycle interface defines the essential normative operations that TOSCA nodes may support.
      metadata: {}
      name: operation_monitor
      properties:
        debug_messages:
          - I'm a debug message.
          - I'm another debug message.
          - I'm yet another debug message.
        monitoring_enabled: true
      requirements: []
      types:
        OperationMonitor:
          description: Monitoring and debugging component
          parent: org.oasis-open.simple:2.0::SoftwareComponent
        org.oasis-open.simple:2.0::Root:
          description: |
            The TOSCA base node type from which all other TOSCA normative node types derive.
        org.oasis-open.simple:2.0::SoftwareComponent:
          description: |
            The TOSCA SoftwareComponent node represents a generic software component that can be managed and run by a TOSCA compute node.
          parent: org.oasis-open.simple:2.0::Root
    edgesOut: []
  _2zumclcE9oMGf4cUW8uw9KalThO:
    metadata:
      puccini:
        kind: NodeTemplate
        version: "1.0"
    properties:
      artifacts: {}
      attributes:
        execution_time: null
        job_id: null
        operation_status: null
        state: null
      capabilities:
        feature:
          attributes: {}
          description: ""
          location:
            column: 5
            path: service_template.node_templates["file_delete_monitor"].capabilities["feature"]
            row: 309
          maxRelationshipCount: -1
          minRelationshipCount: 0
          properties: {}
          types:
            org.oasis-open.simple:2.0::Node:
              description: The Node capability indicates the base capabilities of a TOSCA Node Type.
      description: ""
      directives: []
      interfaces:
        AsyncManagement:
          description: Interface for managing asynchronous operations
          inputs: {}
          metadata: {}
          notifications: {}
          operations:
            check_status:
              dependencies: []
              description: Check operation status
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            execute_async:
              dependencies: []
              description: Execute operation asynchronously
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            wait_completion:
              dependencies: []
              description: Wait for operation completion
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
          types:
            AsyncManagementInterface:
              description: Interface for managing asynchronous operations
        Standard:
          description: The Standard lifecycle interface defines the essential normative operations that TOSCA nodes may support.
          inputs: {}
          metadata: {}
          notifications: {}
          operations:
            configure:
              dependencies: []
              description: Standard lifecycle configure operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            create:
              dependencies: []
              description: Standard lifecycle create operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            delete:
              dependencies: []
              description: Standard lifecycle delete operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            modify:
              dependencies: []
              description: Standard lifecycle modify operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            start:
              dependencies: []
              description: Start the async operation
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            stop:
              dependencies: []
              description: Stop the async operation
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
          types:
            org.oasis-open.simple:2.0::Lifecycle.Standard:
              description: The Standard lifecycle interface defines the essential normative operations that TOSCA nodes may support.
      metadata: {}
      name: file_delete_monitor
      properties:
        fire_and_forget: false
        operation_name: monitor_file_deletion
        polling_interval: 5
        retry_attempts: 20
        timeout_seconds: 30
      requirements:
        - capabilityName: ""
          capabilityPropertyValidators: {}
          capabilityTypeName: org.oasis-open.simple:2.0::Node
          directives: []
          location:
            column: 23
            path: service_template.node_templates["file_delete_monitor"].requirements{0}
            row: 316
          name: dependency
          nodeTemplateName: file_delete_operation
          nodeTemplatePropertyValidators: {}
          nodeTypeName: org.oasis-open.simple:2.0::Root
          optional: false
          relationship:
            attributes: {}
            description: ""
            interfaces:
              Configure:
                description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
                inputs: {}
                metadata: {}
                notifications: {}
                operations:
                  add_source:
                    dependencies: []
                    description: Operation to notify the target node of a source node which is now available via a relationship.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  add_target:
                    dependencies: []
                    description: Operation to notify the source node of a target node being added via a relationship.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  post_configure_source:
                    dependencies: []
                    description: Operation to post-configure the source endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  post_configure_target:
                    dependencies: []
                    description: Operation to post-configure the target endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  pre_configure_source:
                    dependencies: []
                    description: Operation to pre-configure the source endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  pre_configure_target:
                    dependencies: []
                    description: Operation to pre-configure the target endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  remove_target:
                    dependencies: []
                    description: Operation to remove a target node.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  target_changed:
                    dependencies: []
                    description: Operation to notify the source node that some property or attribute of the target node changed.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                types:
                  org.oasis-open.simple:2.0::Relationship.Configure:
                    description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
            metadata: {}
            properties: {}
            types:
              org.oasis-open.simple:2.0::DependsOn:
                description: The DependsOn type represents a general dependency relationship between two nodes.
                parent: org.oasis-open.simple:2.0::Root
              org.oasis-open.simple:2.0::Root:
                description: |
                  The TOSCA base relationship type from which all other normative TOSCA relationship types derive.
      types:
        AsyncOperation:
          description: Abstract long-running operation
          parent: org.oasis-open.simple:2.0::SoftwareComponent
        org.oasis-open.simple:2.0::Root:
          description: |
            The TOSCA base node type from which all other TOSCA normative node types derive.
        org.oasis-open.simple:2.0::SoftwareComponent:
          description: |
            The TOSCA SoftwareComponent node represents a generic software component that can be managed and run by a TOSCA compute node.
          parent: org.oasis-open.simple:2.0::Root
    edgesOut:
      - metadata:
          puccini:
            kind: Relationship
            version: "1.0"
        properties:
          attributes: {}
          capability: feature
          description: ""
          interfaces:
            Configure:
              description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
              inputs: {}
              metadata: {}
              notifications: {}
              operations:
                add_source:
                  dependencies: []
                  description: Operation to notify the target node of a source node which is now available via a relationship.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                add_target:
                  dependencies: []
                  description: Operation to notify the source node of a target node being added via a relationship.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                post_configure_source:
                  dependencies: []
                  description: Operation to post-configure the source endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                post_configure_target:
                  dependencies: []
                  description: Operation to post-configure the target endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                pre_configure_source:
                  dependencies: []
                  description: Operation to pre-configure the source endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                pre_configure_target:
                  dependencies: []
                  description: Operation to pre-configure the target endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                remove_target:
                  dependencies: []
                  description: Operation to remove a target node.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                target_changed:
                  dependencies: []
                  description: Operation to notify the source node that some property or attribute of the target node changed.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
              types:
                org.oasis-open.simple:2.0::Relationship.Configure:
                  description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
          name: dependency
          properties: {}
          types:
            org.oasis-open.simple:2.0::DependsOn:
              description: The DependsOn type represents a general dependency relationship between two nodes.
              parent: org.oasis-open.simple:2.0::Root
            org.oasis-open.simple:2.0::Root:
              description: |
                The TOSCA base relationship type from which all other normative TOSCA relationship types derive.
        targetID: _2zumcoC6bNPHJvptw9PnlNZj6d9
  _2zumcm917XBcB24dxG7oXwva2Ot:
    metadata:
      puccini:
        kind: WorkflowActivity
        version: "1.0"
    properties: {}
    edgesOut: []
  _2zumcmJgFcice5PaFPtkB9AOpk4:
    metadata:
      puccini:
        kind: WorkflowStep
        version: "1.0"
    properties:
      name: start_file_deletion
    edgesOut:
      - metadata:
          puccini:
            kind: NodeTemplateTarget
            version: "1.0"
        properties: {}
        targetID: _2zumcoC6bNPHJvptw9PnlNZj6d9
      - metadata:
          puccini:
            kind: WorkflowActivity
            version: "1.0"
        properties:
          sequence: 0
        targetID: _2zumci7OypXFKPHzTVVhsEOXpQY
      - metadata:
          puccini:
            kind: OnSuccess
            version: "1.0"
        properties: {}
        targetID: _2zumcncC4wQYxdXI96hr9yboIyW
      - metadata:
          puccini:
            kind: OnSuccess
            version: "1.0"
        properties: {}
        targetID: _2zumchwTA5SNEMUCEVdPQcXEpUt
  _2zumcmNoCy9EV0XQaRd3jBa0ABV:
    metadata:
      puccini:
        kind: WorkflowActivity
        version: "1.0"
    properties: {}
    edgesOut: []
  _2zumcmOKt8rxxEJDnGulIQUGDMz:
    metadata:
      puccini:
        kind: WorkflowStep
        version: "1.0"
    properties:
      name: display_debug_2
    edgesOut:
      - metadata:
          puccini:
            kind: NodeTemplateTarget
            version: "1.0"
        properties: {}
        targetID: _2zumcjHQTNa4wuXDNpSSTCT5xnN
      - metadata:
          puccini:
            kind: WorkflowActivity
            version: "1.0"
        properties:
          sequence: 0
        targetID: _2zumckOwdW6e2fvmPD9KoSMcbnh
      - metadata:
          puccini:
            kind: OnSuccess
            version: "1.0"
        properties: {}
        targetID: _2zumcmJgFcice5PaFPtkB9AOpk4
  _2zumcmh1CzwGLyFbe6pj4MwFOr2:
    metadata:
      puccini:
        kind: NodeTemplate
        version: "1.0"
    properties:
      artifacts: {}
      attributes:
        execution_time: null
        job_id: null
        operation_status: null
        state: null
      capabilities:
        feature:
          attributes: {}
          description: ""
          location:
            column: 5
            path: service_template.node_templates["polling_sleep_operation"].capabilities["feature"]
            row: 236
          maxRelationshipCount: -1
          minRelationshipCount: 0
          properties: {}
          types:
            org.oasis-open.simple:2.0::Node:
              description: The Node capability indicates the base capabilities of a TOSCA Node Type.
      description: ""
      directives: []
      interfaces:
        AsyncManagement:
          description: Interface for managing asynchronous operations
          inputs: {}
          metadata: {}
          notifications: {}
          operations:
            check_status:
              dependencies: []
              description: Check operation status
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            execute_async:
              dependencies: []
              description: Execute operation asynchronously
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            wait_completion:
              dependencies: []
              description: Wait for operation completion
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
          types:
            AsyncManagementInterface:
              description: Interface for managing asynchronous operations
        Standard:
          description: The Standard lifecycle interface defines the essential normative operations that TOSCA nodes may support.
          inputs: {}
          metadata: {}
          notifications: {}
          operations:
            configure:
              dependencies: []
              description: Standard lifecycle configure operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            create:
              dependencies: []
              description: Standard lifecycle create operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            delete:
              dependencies: []
              description: Standard lifecycle delete operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            modify:
              dependencies: []
              description: Standard lifecycle modify operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            start:
              dependencies: []
              description: Start the async operation
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            stop:
              dependencies: []
              description: Stop the async operation
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
          types:
            org.oasis-open.simple:2.0::Lifecycle.Standard:
              description: The Standard lifecycle interface defines the essential normative operations that TOSCA nodes may support.
      metadata: {}
      name: polling_sleep_operation
      properties:
        fire_and_forget: false
        operation_name: polling_sleep
        polling_interval: 5
        retry_attempts: 20
        timeout_seconds: 30
      requirements:
        - capabilityName: ""
          capabilityPropertyValidators: {}
          capabilityTypeName: org.oasis-open.simple:2.0::Node
          directives: []
          location:
            column: 23
            path: service_template.node_templates["polling_sleep_operation"].requirements{0}
            row: 244
          name: dependency
          nodeTemplateName: async_environment
          nodeTemplatePropertyValidators: {}
          nodeTypeName: org.oasis-open.simple:2.0::Root
          optional: false
          relationship:
            attributes: {}
            description: ""
            interfaces:
              Configure:
                description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
                inputs: {}
                metadata: {}
                notifications: {}
                operations:
                  add_source:
                    dependencies: []
                    description: Operation to notify the target node of a source node which is now available via a relationship.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  add_target:
                    dependencies: []
                    description: Operation to notify the source node of a target node being added via a relationship.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  post_configure_source:
                    dependencies: []
                    description: Operation to post-configure the source endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  post_configure_target:
                    dependencies: []
                    description: Operation to post-configure the target endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  pre_configure_source:
                    dependencies: []
                    description: Operation to pre-configure the source endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  pre_configure_target:
                    dependencies: []
                    description: Operation to pre-configure the target endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  remove_target:
                    dependencies: []
                    description: Operation to remove a target node.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  target_changed:
                    dependencies: []
                    description: Operation to notify the source node that some property or attribute of the target node changed.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                types:
                  org.oasis-open.simple:2.0::Relationship.Configure:
                    description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
            metadata: {}
            properties: {}
            types:
              org.oasis-open.simple:2.0::DependsOn:
                description: The DependsOn type represents a general dependency relationship between two nodes.
                parent: org.oasis-open.simple:2.0::Root
              org.oasis-open.simple:2.0::Root:
                description: |
                  The TOSCA base relationship type from which all other normative TOSCA relationship types derive.
      types:
        AsyncOperation:
          description: Abstract long-running operation
          parent: org.oasis-open.simple:2.0::SoftwareComponent
        org.oasis-open.simple:2.0::Root:
          description: |
            The TOSCA base node type from which all other TOSCA normative node types derive.
        org.oasis-open.simple:2.0::SoftwareComponent:
          description: |
            The TOSCA SoftwareComponent node represents a generic software component that can be managed and run by a TOSCA compute node.
          parent: org.oasis-open.simple:2.0::Root
    edgesOut:
      - metadata:
          puccini:
            kind: Relationship
            version: "1.0"
        properties:
          attributes: {}
          capability: feature
          description: ""
          interfaces:
            Configure:
              description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
              inputs: {}
              metadata: {}
              notifications: {}
              operations:
                add_source:
                  dependencies: []
                  description: Operation to notify the target node of a source node which is now available via a relationship.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                add_target:
                  dependencies: []
                  description: Operation to notify the source node of a target node being added via a relationship.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                post_configure_source:
                  dependencies: []
                  description: Operation to post-configure the source endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                post_configure_target:
                  dependencies: []
                  description: Operation to post-configure the target endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                pre_configure_source:
                  dependencies: []
                  description: Operation to pre-configure the source endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                pre_configure_target:
                  dependencies: []
                  description: Operation to pre-configure the target endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                remove_target:
                  dependencies: []
                  description: Operation to remove a target node.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                target_changed:
                  dependencies: []
                  description: Operation to notify the source node that some property or attribute of the target node changed.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
              types:
                org.oasis-open.simple:2.0::Relationship.Configure:
                  description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
          name: dependency
          properties: {}
          types:
            org.oasis-open.simple:2.0::DependsOn:
              description: The DependsOn type represents a general dependency relationship between two nodes.
              parent: org.oasis-open.simple:2.0::Root
            org.oasis-open.simple:2.0::Root:
              description: |
                The TOSCA base relationship type from which all other normative TOSCA relationship types derive.
        targetID: _2zumco44dAkdpfimtBZjYSUlUCx
  _2zumcminK1wM1EEHeqA6ALV83Pa:
    metadata:
      puccini:
        kind: NodeTemplate
        version: "1.0"
    properties:
      artifacts: {}
      attributes:
        state: null
      capabilities:
        feature:
          attributes: {}
          description: ""
          location:
            column: 5
            path: service_template.node_templates["debug_checkpoint_3"].capabilities["feature"]
            row: 301
          maxRelationshipCount: -1
          minRelationshipCount: 0
          properties: {}
          types:
            org.oasis-open.simple:2.0::Node:
              description: The Node capability indicates the base capabilities of a TOSCA Node Type.
      description: ""
      directives: []
      interfaces:
        Monitoring:
          description: Interface for monitoring and debugging
          inputs: {}
          metadata: {}
          notifications: {}
          operations:
            display_debug:
              dependencies: []
              description: Display debug information
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            log_status:
              dependencies: []
              description: Log operation status
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
          types:
            MonitoringInterface:
              description: Interface for monitoring and debugging
        Standard:
          description: The Standard lifecycle interface defines the essential normative operations that TOSCA nodes may support.
          inputs: {}
          metadata: {}
          notifications: {}
          operations:
            configure:
              dependencies: []
              description: Standard lifecycle configure operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            create:
              dependencies: []
              description: Standard lifecycle create operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            delete:
              dependencies: []
              description: Standard lifecycle delete operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            modify:
              dependencies: []
              description: Standard lifecycle modify operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            start:
              dependencies: []
              description: Start monitoring
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            stop:
              dependencies: []
              description: Standard lifecycle stop operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
          types:
            org.oasis-open.simple:2.0::Lifecycle.Standard:
              description: The Standard lifecycle interface defines the essential normative operations that TOSCA nodes may support.
      metadata: {}
      name: debug_checkpoint_3
      properties:
        debug_messages:
          - I'm yet another debug message.
        monitoring_enabled: true
      requirements:
        - capabilityName: ""
          capabilityPropertyValidators: {}
          capabilityTypeName: org.oasis-open.simple:2.0::Node
          directives: []
          location:
            column: 23
            path: service_template.node_templates["debug_checkpoint_3"].requirements{0}
            row: 306
          name: dependency
          nodeTemplateName: file_delete_operation
          nodeTemplatePropertyValidators: {}
          nodeTypeName: org.oasis-open.simple:2.0::Root
          optional: false
          relationship:
            attributes: {}
            description: ""
            interfaces:
              Configure:
                description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
                inputs: {}
                metadata: {}
                notifications: {}
                operations:
                  add_source:
                    dependencies: []
                    description: Operation to notify the target node of a source node which is now available via a relationship.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  add_target:
                    dependencies: []
                    description: Operation to notify the source node of a target node being added via a relationship.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  post_configure_source:
                    dependencies: []
                    description: Operation to post-configure the source endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  post_configure_target:
                    dependencies: []
                    description: Operation to post-configure the target endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  pre_configure_source:
                    dependencies: []
                    description: Operation to pre-configure the source endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  pre_configure_target:
                    dependencies: []
                    description: Operation to pre-configure the target endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  remove_target:
                    dependencies: []
                    description: Operation to remove a target node.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  target_changed:
                    dependencies: []
                    description: Operation to notify the source node that some property or attribute of the target node changed.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                types:
                  org.oasis-open.simple:2.0::Relationship.Configure:
                    description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
            metadata: {}
            properties: {}
            types:
              org.oasis-open.simple:2.0::DependsOn:
                description: The DependsOn type represents a general dependency relationship between two nodes.
                parent: org.oasis-open.simple:2.0::Root
              org.oasis-open.simple:2.0::Root:
                description: |
                  The TOSCA base relationship type from which all other normative TOSCA relationship types derive.
      types:
        OperationMonitor:
          description: Monitoring and debugging component
          parent: org.oasis-open.simple:2.0::SoftwareComponent
        org.oasis-open.simple:2.0::Root:
          description: |
            The TOSCA base node type from which all other TOSCA normative node types derive.
        org.oasis-open.simple:2.0::SoftwareComponent:
          description: |
            The TOSCA SoftwareComponent node represents a generic software component that can be managed and run by a TOSCA compute node.
          parent: org.oasis-open.simple:2.0::Root
    edgesOut:
      - metadata:
          puccini:
            kind: Relationship
            version: "1.0"
        properties:
          attributes: {}
          capability: feature
          description: ""
          interfaces:
            Configure:
              description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
              inputs: {}
              metadata: {}
              notifications: {}
              operations:
                add_source:
                  dependencies: []
                  description: Operation to notify the target node of a source node which is now available via a relationship.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                add_target:
                  dependencies: []
                  description: Operation to notify the source node of a target node being added via a relationship.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                post_configure_source:
                  dependencies: []
                  description: Operation to post-configure the source endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                post_configure_target:
                  dependencies: []
                  description: Operation to post-configure the target endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                pre_configure_source:
                  dependencies: []
                  description: Operation to pre-configure the source endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                pre_configure_target:
                  dependencies: []
                  description: Operation to pre-configure the target endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                remove_target:
                  dependencies: []
                  description: Operation to remove a target node.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                target_changed:
                  dependencies: []
                  description: Operation to notify the source node that some property or attribute of the target node changed.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
              types:
                org.oasis-open.simple:2.0::Relationship.Configure:
                  description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
          name: dependency
          properties: {}
          types:
            org.oasis-open.simple:2.0::DependsOn:
              description: The DependsOn type represents a general dependency relationship between two nodes.
              parent: org.oasis-open.simple:2.0::Root
            org.oasis-open.simple:2.0::Root:
              description: |
                The TOSCA base relationship type from which all other normative TOSCA relationship types derive.
        targetID: _2zumcoC6bNPHJvptw9PnlNZj6d9
  _2zumcmwGONyiEnfd8k468JNTC4L:
    metadata:
      puccini:
        kind: WorkflowActivity
        version: "1.0"
    properties: {}
    edgesOut: []
  _2zumcnHle3iu8SIDi3nsVHg1tDb:
    metadata:
      puccini:
        kind: WorkflowStep
        version: "1.0"
    properties:
      name: start_polling_sleep
    edgesOut:
      - metadata:
          puccini:
            kind: NodeTemplateTarget
            version: "1.0"
        properties: {}
        targetID: _2zumcmh1CzwGLyFbe6pj4MwFOr2
      - metadata:
          puccini:
            kind: WorkflowActivity
            version: "1.0"
        properties:
          sequence: 0
        targetID: _2zumcm917XBcB24dxG7oXwva2Ot
      - metadata:
          puccini:
            kind: WorkflowActivity
            version: "1.0"
        properties:
          sequence: 1
        targetID: _2zumcnHrcre9R7ZAyP02BHlP4ra
      - metadata:
          puccini:
            kind: OnSuccess
            version: "1.0"
        properties: {}
        targetID: _2zumckHoKAjGA1gJ9WIZmJ14NiT
  _2zumcnHrcre9R7ZAyP02BHlP4ra:
    metadata:
      puccini:
        kind: WorkflowActivity
        version: "1.0"
    properties: {}
    edgesOut: []
  _2zumcncC4wQYxdXI96hr9yboIyW:
    metadata:
      puccini:
        kind: WorkflowStep
        version: "1.0"
    properties:
      name: display_debug_3
    edgesOut:
      - metadata:
          puccini:
            kind: NodeTemplateTarget
            version: "1.0"
        properties: {}
        targetID: _2zumcminK1wM1EEHeqA6ALV83Pa
      - metadata:
          puccini:
            kind: WorkflowActivity
            version: "1.0"
        properties:
          sequence: 0
        targetID: _2zumckU1sXTZtMO024HaorQDt02
  _2zumcndOCYM710kQdsEd053UF1E:
    metadata:
      puccini:
        kind: WorkflowActivity
        version: "1.0"
    properties: {}
    edgesOut: []
  _2zumcnmFNW8REjiGE4jGKuXHWOo:
    metadata:
      puccini:
        kind: WorkflowStep
        version: "1.0"
    properties:
      name: setup_environment
    edgesOut:
      - metadata:
          puccini:
            kind: NodeTemplateTarget
            version: "1.0"
        properties: {}
        targetID: _2zumco44dAkdpfimtBZjYSUlUCx
      - metadata:
          puccini:
            kind: WorkflowActivity
            version: "1.0"
        properties:
          sequence: 0
        targetID: _2zumcmwGONyiEnfd8k468JNTC4L
      - metadata:
          puccini:
            kind: WorkflowActivity
            version: "1.0"
        properties:
          sequence: 1
        targetID: _2zumcoAw1pG6U1ov3xElDUMX6LA
      - metadata:
          puccini:
            kind: OnSuccess
            version: "1.0"
        properties: {}
        targetID: _2zumcnHle3iu8SIDi3nsVHg1tDb
  _2zumco44dAkdpfimtBZjYSUlUCx:
    metadata:
      puccini:
        kind: NodeTemplate
        version: "1.0"
    properties:
      artifacts: {}
      attributes:
        environment_status: null
        state: null
      capabilities:
        feature:
          attributes: {}
          description: ""
          location:
            column: 5
            path: service_template.node_templates["async_environment"].capabilities["feature"]
            row: 219
          maxRelationshipCount: -1
          minRelationshipCount: 0
          properties: {}
          types:
            org.oasis-open.simple:2.0::Node:
              description: The Node capability indicates the base capabilities of a TOSCA Node Type.
      description: ""
      directives: []
      interfaces:
        Standard:
          description: The Standard lifecycle interface defines the essential normative operations that TOSCA nodes may support.
          inputs: {}
          metadata: {}
          notifications: {}
          operations:
            configure:
              dependencies: []
              description: Configure environment for async operations
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            create:
              dependencies: []
              description: Setup async environment
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            delete:
              dependencies: []
              description: Standard lifecycle delete operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            modify:
              dependencies: []
              description: Standard lifecycle modify operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            start:
              dependencies: []
              description: Standard lifecycle start operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            stop:
              dependencies: []
              description: Standard lifecycle stop operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
          types:
            org.oasis-open.simple:2.0::Lifecycle.Standard:
              description: The Standard lifecycle interface defines the essential normative operations that TOSCA nodes may support.
      metadata: {}
      name: async_environment
      properties:
        async_directory: ~/.ansible_async
        setup_required: true
      requirements: []
      types:
        AsyncEnvironment:
          description: Environment setup for asynchronous operations
          parent: org.oasis-open.simple:2.0::SoftwareComponent
        org.oasis-open.simple:2.0::Root:
          description: |
            The TOSCA base node type from which all other TOSCA normative node types derive.
        org.oasis-open.simple:2.0::SoftwareComponent:
          description: |
            The TOSCA SoftwareComponent node represents a generic software component that can be managed and run by a TOSCA compute node.
          parent: org.oasis-open.simple:2.0::Root
    edgesOut: []
  _2zumcoAw1pG6U1ov3xElDUMX6LA:
    metadata:
      puccini:
        kind: WorkflowActivity
        version: "1.0"
    properties: {}
    edgesOut: []
  _2zumcoC6bNPHJvptw9PnlNZj6d9:
    metadata:
      puccini:
        kind: NodeTemplate
        version: "1.0"
    properties:
      artifacts: {}
      attributes:
        execution_time: null
        job_id: null
        operation_status: null
        state: null
      capabilities:
        feature:
          attributes: {}
          description: ""
          location:
            column: 5
            path: service_template.node_templates["file_delete_operation"].capabilities["feature"]
            row: 287
          maxRelationshipCount: -1
          minRelationshipCount: 0
          properties: {}
          types:
            org.oasis-open.simple:2.0::Node:
              description: The Node capability indicates the base capabilities of a TOSCA Node Type.
      description: ""
      directives: []
      interfaces:
        AsyncManagement:
          description: Interface for managing asynchronous operations
          inputs: {}
          metadata: {}
          notifications: {}
          operations:
            check_status:
              dependencies: []
              description: Check operation status
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            execute_async:
              dependencies: []
              description: Execute operation asynchronously
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            wait_completion:
              dependencies: []
              description: Wait for operation completion
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
          types:
            AsyncManagementInterface:
              description: Interface for managing asynchronous operations
        Standard:
          description: The Standard lifecycle interface defines the essential normative operations that TOSCA nodes may support.
          inputs: {}
          metadata: {}
          notifications: {}
          operations:
            configure:
              dependencies: []
              description: Standard lifecycle configure operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            create:
              dependencies: []
              description: Standard lifecycle create operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            delete:
              dependencies: []
              description: Standard lifecycle delete operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            modify:
              dependencies: []
              description: Standard lifecycle modify operation.
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            start:
              dependencies: []
              description: Start the async operation
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
            stop:
              dependencies: []
              description: Stop the async operation
              implementation: ""
              inputs: {}
              outputs: {}
              timeout: -1
          types:
            org.oasis-open.simple:2.0::Lifecycle.Standard:
              description: The Standard lifecycle interface defines the essential normative operations that TOSCA nodes may support.
      metadata: {}
      name: file_delete_operation
      properties:
        delay_before_execution: 10
        fire_and_forget: true
        operation_name: delete_test_file
        operation_type: delete
        polling_interval: 5
        retry_attempts: 20
        target_file: /tmp/test_file
        timeout_seconds: 30
      requirements:
        - capabilityName: ""
          capabilityPropertyValidators: {}
          capabilityTypeName: org.oasis-open.simple:2.0::Node
          directives: []
          location:
            column: 23
            path: service_template.node_templates["file_delete_operation"].requirements{0}
            row: 298
          name: dependency
          nodeTemplateName: debug_checkpoint_2
          nodeTemplatePropertyValidators: {}
          nodeTypeName: org.oasis-open.simple:2.0::Root
          optional: false
          relationship:
            attributes: {}
            description: ""
            interfaces:
              Configure:
                description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
                inputs: {}
                metadata: {}
                notifications: {}
                operations:
                  add_source:
                    dependencies: []
                    description: Operation to notify the target node of a source node which is now available via a relationship.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  add_target:
                    dependencies: []
                    description: Operation to notify the source node of a target node being added via a relationship.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  post_configure_source:
                    dependencies: []
                    description: Operation to post-configure the source endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  post_configure_target:
                    dependencies: []
                    description: Operation to post-configure the target endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  pre_configure_source:
                    dependencies: []
                    description: Operation to pre-configure the source endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  pre_configure_target:
                    dependencies: []
                    description: Operation to pre-configure the target endpoint.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  remove_target:
                    dependencies: []
                    description: Operation to remove a target node.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                  target_changed:
                    dependencies: []
                    description: Operation to notify the source node that some property or attribute of the target node changed.
                    implementation: ""
                    inputs: {}
                    outputs: {}
                    timeout: -1
                types:
                  org.oasis-open.simple:2.0::Relationship.Configure:
                    description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
            metadata: {}
            properties: {}
            types:
              org.oasis-open.simple:2.0::DependsOn:
                description: The DependsOn type represents a general dependency relationship between two nodes.
                parent: org.oasis-open.simple:2.0::Root
              org.oasis-open.simple:2.0::Root:
                description: |
                  The TOSCA base relationship type from which all other normative TOSCA relationship types derive.
      types:
        AsyncOperation:
          description: Abstract long-running operation
          parent: org.oasis-open.simple:2.0::SoftwareComponent
        FileOperation:
          description: File system operation
          parent: AsyncOperation
        org.oasis-open.simple:2.0::Root:
          description: |
            The TOSCA base node type from which all other TOSCA normative node types derive.
        org.oasis-open.simple:2.0::SoftwareComponent:
          description: |
            The TOSCA SoftwareComponent node represents a generic software component that can be managed and run by a TOSCA compute node.
          parent: org.oasis-open.simple:2.0::Root
    edgesOut:
      - metadata:
          puccini:
            kind: Relationship
            version: "1.0"
        properties:
          attributes: {}
          capability: feature
          description: ""
          interfaces:
            Configure:
              description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
              inputs: {}
              metadata: {}
              notifications: {}
              operations:
                add_source:
                  dependencies: []
                  description: Operation to notify the target node of a source node which is now available via a relationship.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                add_target:
                  dependencies: []
                  description: Operation to notify the source node of a target node being added via a relationship.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                post_configure_source:
                  dependencies: []
                  description: Operation to post-configure the source endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                post_configure_target:
                  dependencies: []
                  description: Operation to post-configure the target endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                pre_configure_source:
                  dependencies: []
                  description: Operation to pre-configure the source endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                pre_configure_target:
                  dependencies: []
                  description: Operation to pre-configure the target endpoint.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                remove_target:
                  dependencies: []
                  description: Operation to remove a target node.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
                target_changed:
                  dependencies: []
                  description: Operation to notify the source node that some property or attribute of the target node changed.
                  implementation: ""
                  inputs: {}
                  outputs: {}
                  timeout: -1
              types:
                org.oasis-open.simple:2.0::Relationship.Configure:
                  description: The Configure lifecycle interface defines the essential normative operations that TOSCA relationships may support.
          name: dependency
          properties: {}
          types:
            org.oasis-open.simple:2.0::DependsOn:
              description: The DependsOn type represents a general dependency relationship between two nodes.
              parent: org.oasis-open.simple:2.0::Root
            org.oasis-open.simple:2.0::Root:
              description: |
                The TOSCA base relationship type from which all other normative TOSCA relationship types derive.
        targetID: _2zumcjHQTNa4wuXDNpSSTCT5xnN
