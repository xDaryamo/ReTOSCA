version: "1.0"
metadata:
  history:
    - description: compile
      timestamp: "2025-04-23T16:43:13.304+02:00"
    - description: resolve
      timestamp: "2025-04-23T16:43:13.335+02:00"
    - description: coerce
      timestamp: "2025-04-23T16:43:13.345+02:00"
  puccini:
    scriptlets:
      tosca:
        coerce: |-
          const traversal = require('tosca.lib.traversal');
          const tosca = require('tosca.lib.utils');

          traversal.coerce();
          if (puccini.arguments.history !== 'false')
            tosca.addHistory('coerce');
          puccini.write(clout);
        comparer:
          version: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.2.2
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.2.2
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.2.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.2.2

            exports.compare = function(a, b) {
              if (a.$comparer !== b.$comparer)
                throw 'both values must be of type "version"';
              if (a.major !== b.major)
                return a.major < b.major ? -1 : 1;
              if (a.minor !== b.minor)
                return a.minor < b.minor ? -1 : 1;
              if (a.fix !== b.fix)
                return a.fix < b.fix ? -1 : 1;
              let aq = a.qualifier.toLowerCase();
              let bq = b.qualifier.toLowerCase();
              if (aq !== bq) // note: the qualifier is compared alphabetically, *not* semantically
                return aq < bq ? -1 : 1;
              if (a.build !== b.build)
                return a.build < b.build ? -1 : 1;
              return 0;
            };
        constraint:
          _format: |-
            exports.validate = function(v, format) {
              if (arguments.length !== 2)
                throw 'must have 1 argument';
              if (!puccini.isType(v, 'ard.string'))
                return 'not a string';
              try {
                puccini.validateFormat(v, format);
              } catch (x) {
                if (x.value && x.value.error)
                  // Unwrap Go error
                  return x.value.error();
                else
                  throw x;
              }
              return true;
            };
          equal: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2

            const tosca = require('tosca.lib.utils');

            exports.validate = function(v1, v2) {
              if (arguments.length !== 2)
                throw 'must have 1 argument';
              return tosca.compare(v1, v2) === 0;
            };
          greater_or_equal: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2

            const tosca = require('tosca.lib.utils');

            exports.validate = function(v1, v2) {
              if (arguments.length !== 2)
                throw 'must have 1 argument';
              return tosca.compare(v1, v2) >= 0;
            };
          greater_than: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2

            const tosca = require('tosca.lib.utils');

            exports.validate = function(v1, v2) {
              if (arguments.length !== 2)
                throw 'must have 1 argument';
              return tosca.compare(v1, v2) > 0;
            };
          in_range: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2

            const tosca = require('tosca.lib.utils');

            exports.validate = function(v, lower, upper) {
              if (arguments.length !== 3)
                throw 'must have 2 arguments';
              if ((v.lower !== undefined) && (v.upper !== undefined))
                // Special case: is the range in range?
                return (tosca.compare(v.lower, lower) >= 0) && (tosca.compare(v.upper, upper) <= 0);
              else
                return (tosca.compare(v, lower) >= 0) && (tosca.compare(v, upper) <= 0);
            };
          length: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2

            const tosca = require('tosca.lib.utils');

            exports.validate = function(v, length) {
              if (arguments.length !== 2)
                throw 'must have 1 argument';
              return tosca.getLength(v) == length;
            };
          less_or_equal: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2

            const tosca = require('tosca.lib.utils');

            exports.validate = function(v1, v2) {
              if (arguments.length !== 2)
                throw 'must have 1 argument';
              return tosca.compare(v1, v2) <= 0;
            };
          less_than: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2

            const tosca = require('tosca.lib.utils');

            exports.validate = function(v1, v2) {
              if (arguments.length !== 2)
                throw 'must have 1 argument';
              return tosca.compare(v1, v2) < 0;
            };
          max_length: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2

            const tosca = require('tosca.lib.utils');

            exports.validate = function(v, length) {
              if (arguments.length !== 2)
                throw 'must have 1 argument';
              return tosca.getLength(v) <= length;
            };
          min_length: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2

            const tosca = require('tosca.lib.utils');

            exports.validate = function(v, length) {
              if (arguments.length !== 2)
                throw 'must have 1 argument';
              return tosca.getLength(v) >= length;
            };
          pattern: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2

            exports.validate = function(v, re) {
              if (arguments.length !== 2)
                throw 'must have 1 argument';
              if (v.$string !== undefined)
                v = v.$string;
              return new RegExp('^' + re + '$').test(v);
            };
          schema: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3

            exports.validate = function() {
              // TODO
              return true;
            };
          valid_values: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 3.6.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 3.5.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 3.5.2

            const tosca = require('tosca.lib.utils');

            exports.validate = function(v) {
              let values = Array.prototype.slice.call(arguments, 1);
              for (let i = 0, l = values.length; i < l; i++)
                if (tosca.deepEqual(values[i], v))
                  return true;
              return false;
            };
        function:
          _get_target_name: |-
            const tosca = require('tosca.lib.utils');

            exports.evaluate = function() {
              if (!this || !this.target)
                throw 'TARGET cannot be used in this context';
              if (!tosca.isNodeTemplate(this.target))
                throw 'TARGET is not a node template';
              return this.target.properties.name;
            };
          concat: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 4.3.1
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 4.3.1
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 4.3.1
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 4.3.1

            exports.evaluate = function() {
              let a = [];
              let length = arguments.length;
              for (let i = 0; i < length; i++) {
                let argument = arguments[i];
                if (argument.$string !== undefined)
                  argument = argument.$string;
                a.push(argument);
              }
              return a.join('');
            };
          get_artifact: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 4.8.1
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 4.8.1
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 4.8.1
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 4.8.1

            const tosca = require('tosca.lib.utils');

            exports.evaluate = function(entity, artifactName, location, remove) {
              if (arguments.length < 2)
                throw 'must have at least 2 arguments';
              let nodeTemplate = tosca.getModelableEntity.call(this, entity).properties;
              if (!nodeTemplate.artifacts || !(artifactName in nodeTemplate.artifacts))
                throw puccini.sprintf('artifact %q not found in %q', artifactName, nodeTemplate.name);
              let artifact = nodeTemplate.artifacts[artifactName];
              if (artifact.$artifact === undefined)
                return artifact.sourcePath;
              return artifact.$artifact;
            };
          get_attribute: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 4.5.1
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 4.5.1
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 4.5.1
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 4.5.1

            const tosca = require('tosca.lib.utils');

            exports.evaluate = function(entity, first) {
              return tosca.getNestedValue.call(this, 'attribute', 'attributes', arguments);
            };
          get_input: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 4.4.1
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 4.4.1
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 4.4.1
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 4.4.1

            const tosca = require('tosca.lib.utils');

            exports.evaluate = function(input) {
              if (arguments.length !== 1)
                throw 'must have 1 argument';
              if (!tosca.isTosca(clout))
                throw 'Clout is not TOSCA';
              let inputs = clout.properties.tosca.inputs;
              if (!(input in inputs))
                throw puccini.sprintf('input %q not found', input);
              let r = inputs[input];
              r = clout.coerce(r);
              return r;
            };
          get_nodes_of_type: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 4.7.1
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 4.7.1
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 4.7.1
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 4.7.1

            const tosca = require('tosca.lib.utils');

            exports.evaluate = function(typeName) {
              if (arguments.length !== 1)
                throw 'must have 1 argument';
              let names = [];
              for (let id in clout.vertexes) {
                let vertex = clout.vertexes[id];
                if (tosca.isTosca(vertex))
                  names.push(vertex.properties.name);
              }
              return names;
            };
          get_operation_output: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 4.6.1
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 4.6.1
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 4.6.1
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 4.6.1

            exports.evaluate = function() {
              return 'TODO';
            };
          get_property: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 4.4.2
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 4.4.2
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 4.4.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 4.4.2

            const tosca = require('tosca.lib.utils');

            exports.evaluate = function() {
              return tosca.getNestedValue.call(this, 'property', 'properties', arguments);
            };
          join: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 4.3.2

            exports.evaluate = function() {
              let length = arguments.length;
              if ((length < 1) || (length > 2))
                throw 'must have 1 or 2 arguments';
              let delimiter = (length == 2) ? arguments[1] : '';
              let args = arguments[0];
              length = args.length;
              let a = [];
              for (let i = 0; i < length; i++) {
                let argument = args[i];
                if (argument.$string !== undefined)
                  argument = argument.$string;
                a.push(argument);
              }
              return a.join(delimiter);
            };
          token: |-
            // [TOSCA-Simple-Profile-YAML-v1.3] @ 4.3.3
            // [TOSCA-Simple-Profile-YAML-v1.2] @ 4.3.3
            // [TOSCA-Simple-Profile-YAML-v1.1] @ 4.3.2
            // [TOSCA-Simple-Profile-YAML-v1.0] @ 4.3.2

            exports.evaluate = function(v, separators, index) {
              if (arguments.length !== 3)
                throw 'must have 3 arguments';
              if (v.$string !== undefined)
                v = v.$string;
              let s = v.split(new RegExp('[' + escape(separators) + ']'));
              return s[index];
            };

            function escape(s) {
              return s.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
            }
        lib:
          traversal: |-
            const tosca = require('tosca.lib.utils');

            exports.toCoercibles = function(clout_) {
              if (!clout_)
                clout_ = clout;
              exports.traverseValues(clout_, function(data) {
                return clout_.newCoercible(data.value, data.site, data.source, data.target);
              });
            };

            exports.unwrapCoercibles = function(clout_) {
              if (!clout_)
                clout_ = clout;
              exports.traverseValues(clout_, function(data) {
                return clout_.unwrap(data.value);
              });
            };

            exports.coerce = function(clout_) {
              if (!clout_)
                clout_ = clout;
              exports.toCoercibles(clout_);
              exports.traverseValues(clout_, function(data) {
                return clout_.coerce(data.value);
              });
            };

            exports.getValueType = function(clout_) {
              if (!clout_)
                clout_ = clout;
              let valueType = {};
              exports.traverseValues(clout_, function(data) {
                if (data.value.$meta)
                  valueType[data.path.join('.')] = data.value.$meta.type;
                return data.value;
              });
              return valueType;
            };

            exports.hasQuirk = function(clout_, quirk) {
              if (!clout_)
                clout_ = clout;
              let quirks = clout_.properties.tosca.metadata['puccini.quirks'];
              if (quirks !== undefined) {
                quirks = quirks.split(',');
                for (let q = 0, l = quirks.length; q < l; q++)
                  if (quirks[q] === quirk)
                    return true;
              }
              return false;
            };

            exports.traverseValues = function(clout_, traverser) {
              if (!clout_)
                clout_ = clout;

              if (tosca.isTosca(clout_)) {
                exports.traverseObjectValues(traverser, ['inputs'], clout_.properties.tosca.inputs);
                exports.traverseObjectValues(traverser, ['outputs'], clout_.properties.tosca.outputs);
              }

              for (let vertexId in clout_.vertexes) {
                let vertex = clout_.vertexes[vertexId];
                if (!tosca.isTosca(vertex))
                  continue;

                if (tosca.isNodeTemplate(vertex)) {
                  let nodeTemplate = vertex.properties;
                  let path = ['nodeTemplates', nodeTemplate.name];

                  exports.traverseObjectValues(traverser, copyAndPush(path, 'properties'), nodeTemplate.properties, vertex);
                  exports.traverseObjectValues(traverser, copyAndPush(path, 'attributes'), nodeTemplate.attributes, vertex);
                  exports.traverseInterfaceValues(traverser, copyAndPush(path, 'interfaces'), nodeTemplate.interfaces, vertex)

                  for (let capabilityName in nodeTemplate.capabilities) {
                    let capability = nodeTemplate.capabilities[capabilityName];
                    let capabilityPath = copyAndPush(path, 'capabilities', capabilityName);
                    exports.traverseObjectValues(traverser, copyAndPush(capabilityPath, 'properties'), capability.properties, vertex);
                    exports.traverseObjectValues(traverser, copyAndPush(capabilityPath, 'attributes'), capability.attributes, vertex);
                  }

                  for (let artifactName in nodeTemplate.artifacts) {
                    let artifact = nodeTemplate.artifacts[artifactName];
                    let artifactPath = copyAndPush(path, 'artifacts', artifactName);
                    exports.traverseObjectValues(traverser, copyAndPush(artifactPath, 'properties'), artifact.properties, vertex);
                    if (artifact.credential !== null)
                      try {
                        artifact.credential = traverser({
                          path: copyAndPush(artifactPath, 'credential'),
                          value: artifact.credential,
                          site: vertex
                        });
                      } catch (x) {
                        if ((typeof problems !== 'undefined') && x.value && x.value.error)
                          // Unwrap Go error
                          problems.reportError(x.value);
                        else
                          throw x;
                      }
                  }

                  for (let e = 0, l = vertex.edgesOut.size(); e < l; e++) {
                    let edge = vertex.edgesOut[e];
                    if (!tosca.isTosca(edge, 'Relationship'))
                      continue;

                    let relationship = edge.properties;
                    let relationshipPath = copyAndPush(path, 'relationships', relationship.name);
                    exports.traverseObjectValues(traverser, copyAndPush(relationshipPath, 'properties'), relationship.properties, edge, vertex, edge.target);
                    exports.traverseObjectValues(traverser,copyAndPush(relationshipPath, 'attributes'), relationship.attributes, edge, vertex, edge.target);
                    exports.traverseInterfaceValues(traverser, copyAndPush(relationshipPath, 'interfaces'), relationship.interfaces, edge, vertex, edge.target);
                  }
                } else if (tosca.isTosca(vertex, 'Group')) {
                  let group = vertex.properties;
                  let path = ['groups', group.name];

                  exports.traverseObjectValues(traverser, copyAndPush(path, 'properties'), group.properties, vertex);
                  exports.traverseInterfaceValues(traverser, copyAndPush(path, 'attributes'), group.interfaces, vertex)
                } else if (tosca.isTosca(vertex, 'Policy')) {
                  let policy = vertex.properties;
                  let path = ['policies', policy.name];

                  exports.traverseObjectValues(traverser, copyAndPush(path, 'properties'), policy.properties, vertex);
                } else if (tosca.isTosca(vertex, 'Substitution')) {
                  let substitution = vertex.properties;
                  let path = ['substitution'];

                  exports.traverseObjectValues(traverser, copyAndPush(path, 'properties'), substitution.properties, vertex);
                }
              }
            };

            exports.traverseInterfaceValues = function(traverser, path, interfaces, site, source, target) {
              for (let interfaceName in interfaces) {
                let interface_ = interfaces[interfaceName];
                let interfacePath = copyAndPush(path, interfaceName)
                exports.traverseObjectValues(traverser, copyAndPush(interfacePath, 'inputs'), interface_.inputs, site, source, target);
                for (let operationName in interface_.operations) {
                  let operationPath = copyAndPush(interfacePath, 'operations', operationName);
                  exports.traverseObjectValues(traverser, operationPath, interface_.operations[operationName].inputs, site, source, target);
                  exports.traverseObjectValues(traverser, operationPath, interface_.operations[operationName].outputs, site, source, target);
                }
                for (let notificationName in interface_.notifications) {
                  let notificationPath = copyAndPush(interfacePath, 'notifications', notificationName);
                  exports.traverseObjectValues(traverser, notificationPath, interface_.notifications[notificationName].outputs, site, source, target);
                }
              }
            };

            exports.traverseObjectValues = function(traverser, path, object, site, source, target) {
              for (let key in object)
                try {
                  object[key] = traverser({
                    path: copyAndPush(path, key),
                    value: object[key],
                    site: site,
                    source: source,
                    target: target
                  });
                } catch (x) {
                  if ((typeof problems !== 'undefined') && x.value && x.value.error)
                    // Unwrap Go error
                    problems.reportError(x.value);
                  else
                    throw x;
                }
            };

            function copyAndPush(array) {
              let array_ = [];
              for (let i = 0, l = array.length; i < l; i++)
                array_.push(array[i]);
              for (let i = 1, l = arguments.length; i < l; i++)
                array_.push(arguments[i]);
              return array_;
            }
          utils: |-
            exports.isTosca = function(o, kind) {
              if (o.metadata === undefined)
                return false;
              o = o.metadata['puccini'];
              if (o === undefined)
                return false;
              if (o.version !== '1.0')
                return false;
              if (kind !== undefined)
                return kind === o.kind;
              return true;
            };

            exports.isNodeTemplate = function(vertex, typeName) {
              if (exports.isTosca(vertex, 'NodeTemplate')) {
                if (typeName !== undefined)
                  return typeName in vertex.properties.types;
                return true;
              }
              return false;
            };

            exports.setOutputValue = function(name, value) {
              if (clout.properties.tosca === undefined)
                return false;
              let output = clout.properties.tosca.outputs[name];
              if (output === undefined)
                return false;

              if (output.$type && output.$type.type)
                switch (output.$type.type.name) {
                case 'boolean':
                  value = (value === 'true');
                  break;
                case 'integer':
                  value = parseInt(value);
                  break;
                case 'float':
                  value = parseFloat(value);
                  break;
                }

              output.$value = value;
              return true;
            };

            exports.getPolicyTargets = function(vertex) {
              let targets = [];

              function addTarget(target) {
                for (let t = 0, l = targets.length; t < l; t++)
                  if (targets[t].name === target.name)
                    return;
                targets.push(target);
              }

              for (let e = 0, l = vertex.edgesOut.size(); e < l; e++) {
                let edge = vertex.edgesOut[e];
                if (exports.isTosca(edge, 'NodeTemplateTarget'))
                  targets.push(clout.vertexes[edge.targetID].properties);
                else if (toexportssca.isTosca(edge, 'GroupTarget')) {
                  let members = exports.getGroupMembers(clout.vertexes[edge.targetID]);
                  for (let m = 0, ll = members.length; m < ll; m++)
                    addTarget(members[m])
                }
              }
              return targets;
            };

            exports.getGroupMembers = function(vertex) {
              let members = [];
              for (let e = 0, l = vertex.edgesOut.size(); e < l; e++) {
                let edge = vertex.edgesOut[e];
                if (exports.isTosca(edge, 'Member'))
                  members.push(clout.vertexes[edge.targetID].properties);
              }
              return members;
            };

            exports.addHistory = function(description) {
              let metadata = clout.metadata;
              if (metadata === undefined)
                metadata = clout.metadata = {};
              let history = metadata.history;
              if (history === undefined)
                history = [];
              else
                history = history.slice(0);
              history.push({
                timestamp: puccini.nowString(),
                description: description
              });
              metadata.history = history;
            };

            exports.getNestedValue = function(singular, plural, args) {
              args = Array.prototype.slice.call(args);
              let length = args.length;
              if (length < 2)
                throw 'must have at least 2 arguments';
              let vertex = exports.getModelableEntity.call(this, args[0]);
              let nodeTemplate = vertex.properties;
              let value = nodeTemplate[plural];
              let a = 1;
              let arg = args[a];
              let nextArg = args[a+1];
              let count = 0;
              if (arg in nodeTemplate.capabilities) {
                value = nodeTemplate.capabilities[arg][plural];
                singular = puccini.sprintf('capability %q %s', arg, singular);
                arg = args[++a];
              } else for (let e = 0, l = vertex.edgesOut.size(); e < l; e++) {
                let edge = vertex.edgesOut[e];
                if (!exports.isTosca(edge, 'Relationship'))
                  continue;
                let relationship = edge.properties;
                if (relationship.name === arg)
                  if (count++ === nextArg) {
                    value = relationship[plural];
                    singular = puccini.sprintf('relationship %q %s', arg, singular);
                    a += 2;
                    arg = args[a];
                    break;
                  }
              }
              if ((typeof value === 'object') && (value !== null) && (arg in value))
                value = value[arg];
              else
                throw puccini.sprintf('%s %q not found in %q', singular, arg, nodeTemplate.name);
              value = clout.coerce(value);
              for (let i = a + 1; i < length; i++) {
                arg = args[i];
                if ((typeof value === 'object') && (value !== null) && (arg in value))
                  value = value[arg];
                else
                  throw puccini.sprintf('nested %s %q not found in %q', singular, args.slice(a, i+1).join('.'), nodeTemplate.name);
              }
              return value;
            };

            exports.getModelableEntity = function(entity) {
              let vertex;
              switch (entity) {
              case 'SELF':
                if (!this || !this.site)
                  throw puccini.sprintf('%q cannot be used in this context', entity);
                vertex = this.site;
                break;
              case 'SOURCE':
                if (!this || !this.source)
                  throw puccini.sprintf('%q cannot be used in this context', entity);
                vertex = this.source;
                break;
              case 'TARGET':
                if (!this || !this.target)
                  throw puccini.sprintf('%q cannot be used in this context', entity);
                vertex = this.target;
                break;
              case 'HOST':
                if (!this || !this.site)
                  throw puccini.sprintf('%q cannot be used in this context', entity);
                vertex = exports.getHost(this.site);
                break;
              default:
                for (let vertexId in clout.vertexes) {
                  let vertex = clout.vertexes[vertexId];
                  if (exports.isNodeTemplate(vertex) && (vertex.properties.name === entity))
                    return vertex;
                }
                vertex = {};
              }
              if (exports.isNodeTemplate(vertex))
                return vertex;
              else
                throw puccini.sprintf('%q node template not found', entity);
            };

            exports.getHost = function(vertex) {
              for (let e = 0, l = vertex.edgesOut.size(); e < l; e++) {
                let edge = vertex.edgesOut[e];
                if (exports.isTosca(edge, 'Relationship')) {
                  for (let typeName in edge.properties.types) {
                    let type = edge.properties.types[typeName];
                    if (type.metadata.role === 'host')
                      return edge.target;
                  }
                }
              }
              if (exports.isNodeTemplate(vertex))
                throw puccini.sprintf('"HOST" not found for node template %q', vertex.properties.name);
              else
                throw '"HOST" not found';
            };

            exports.getComparable = function(v) {
              if ((v === undefined) || (v === null))
                return null;
              let c = v.$number;
              if (c !== undefined)
                return c;
              c = v.$string;
              if (c !== undefined)
                return c;
              return v;
            };

            exports.getLength = function(v) {
              if (v.$string !== undefined)
                v = v.$string;
              let length = v.length;
              if (length === undefined)
                length = Object.keys(v).length;
              return length;
            };

            exports.compare = function(v1, v2) {
              let c = v1.$comparer;
              if (c === undefined)
                c = v2.$comparer;
              if (c !== undefined)
                return clout.call(c, 'compare', [v1, v2]);
              v1 = exports.getComparable(v1);
              v2 = exports.getComparable(v2);
              if (v1 == v2)
                return 0;
              else if (v1 < v2)
                return -1;
              else
                return 1;
            };

            // See: https://stackoverflow.com/a/45683145
            exports.deepEqual = function(v1, v2) {
              if (v1 === v2)
                return true;

              if (exports.isPrimitive(v1) && exports.isPrimitive(v2))
                return v1 === v2;

              if (Object.keys(v1).length !== Object.keys(v2).length)
                return false;

              for (let key in v1) {
                if (!(key in v2)) return false;
                if (!exports.deepEqual(v1[key], v2[key])) return false;
              }

              return true;
            };

            exports.isPrimitive = function(obj) {
              return obj !== Object(obj);
            };
        outputs: |-
          const traversal = require('tosca.lib.traversal');
          const tosca = require('tosca.lib.utils');

          traversal.coerce();

          if (tosca.isTosca(clout))
              puccini.write(clout.properties.tosca.outputs);
        resolve: |-
          const traversal = require('tosca.lib.traversal');
          const tosca = require('tosca.lib.utils');

          const enforceCapabilityOccurrences = !traversal.hasQuirk(clout, 'capabilities.occurrences.permissive');

          // Remove existing relationships
          let nodeTemplateVertexes = [];
          for (let vertexId in clout.vertexes) {
            let vertex = clout.vertexes[vertexId];
            if (tosca.isNodeTemplate(vertex)) {
              nodeTemplateVertexes.push(vertex);
              let remove = [];
              for (let e = 0, l = vertex.edgesOut.size(); e < l; e++) {
                let edge = vertex.edgesOut[e];
                if (tosca.isTosca(edge, 'Relationship'))
                  remove.push(edge);
              }
              for (let e = 0, l = remove.length; e < l; e++)
                remove[e].remove();
            }
          }

          // For consistent results, we will sort the node templates by name
          nodeTemplateVertexes.sort(function(a, b) {
            return a.properties.name < b.properties.name ? -1 : 1;
          });

          traversal.toCoercibles();

          // Resolve all requirements
          for (let v = 0, l = nodeTemplateVertexes.length; v < l; v++) {
            let vertex = nodeTemplateVertexes[v];
            let nodeTemplate = vertex.properties;
            let requirements = nodeTemplate.requirements;
            for (let r = 0, ll = requirements.length; r < ll; r++) {
              let requirement = requirements[r];
              resolve(vertex, nodeTemplate, requirement);
            }
          }

          if (enforceCapabilityOccurrences)
            for (let v = 0, l = nodeTemplateVertexes.length; v < l; v++) {
              let vertex = nodeTemplateVertexes[v];
              let nodeTemplate = vertex.properties;
              let capabilities = nodeTemplate.capabilities;
              for (let capabilityName in capabilities) {
                let capability = capabilities[capabilityName];
                let relationshipCount = countRelationships(vertex, capabilityName);
                let minRelationshipCount = capability.minRelationshipCount;
                if (relationshipCount < minRelationshipCount)
                  notEnoughRelationships(capability.location, relationshipCount, minRelationshipCount)
              }
            }

          traversal.unwrapCoercibles();

          if (puccini.arguments.history !== 'false')
            tosca.addHistory('resolve');
          puccini.write(clout)

          function resolve(sourceVertex, sourceNodeTemplate, requirement) {
            let location = requirement.location;
            let name = requirement.name;

            if (isSubstituted(sourceNodeTemplate.name, name)) {
              puccini.log.debugf('%s: skipping because in substitution mappings', location.path)
              return;
            }

            let candidates = gatherCandidateNodeTemplates(sourceVertex, requirement);
            if (candidates.length === 0) {
              unsatisfied(location, name, 'there are no candidate node templates');
              return;
            }

            candidates = gatherCandidateCapabilities(requirement, candidates);
            if (candidates.length === 0) {
              unsatisfied(location, name, 'no candidate node template provides required capability');
              return;
            }

            // Gather priority candidates: those that have not yet fulfilled their minimum relationship count
            let priorityCandidates = [];
            for (let c = 0, l = candidates.length; c < l; c++) {
              let candidate = candidates[c];
              if ((candidate.capability.minRelationshipCount !== 0) && (countRelationships(candidate.vertex, candidate.capabilityName) < candidate.capability.minRelationshipCount))
                priorityCandidates.push(candidate);
            }

            let chosen = null;

            if (priorityCandidates.length !== 0)
              // Of the priority candidates, pick the one with the highest minimum relationship count
              // (needs to be fulfilled soonest)
              for (let c = 0, l = priorityCandidates.length; c < l; c++) {
                let candidate = priorityCandidates[c];
                if ((chosen === null) || (candidate.capability.minRelationshipCount > chosen.capability.minRelationshipCount))
                  chosen = candidate;
              }
            else
              // Of the candidates, pick the one with highest maximum relationship count
              // (has the most room)
              for (let c = 0, l = candidates.length; c < l; c++) {
                let candidate = candidates[c];
                if ((chosen === null) || isMaxCountGreater(candidate.capability.maxRelationshipCount, chosen.capability.maxRelationshipCount))
                  chosen = candidate;
              }

            puccini.log.debugf('%s: satisfied %q with capability %q in node template %q', location.path, name, chosen.capabilityName, chosen.nodeTemplateName);
            addRelationship(sourceVertex, requirement, chosen.vertex, chosen.capabilityName);
          }

          function gatherCandidateNodeTemplates(sourceVertex, requirement) {
            let path = requirement.location.path;
            let nodeTemplateName = requirement.nodeTemplateName;
            let nodeTypeName = requirement.nodeTypeName;
            let nodeTemplatePropertyValidators = requirement.nodeTemplatePropertyValidators;
            let capabilityPropertyValidatorsMap = requirement.capabilityPropertyValidators;

            let candidates = [];
            for (let v = 0, l = nodeTemplateVertexes.length; v < l; v++) {
              let vertex = nodeTemplateVertexes[v];
              let candidateNodeTemplate = vertex.properties;
              let candidateNodeTemplateName = candidateNodeTemplate.name;

              if ((nodeTemplateName !== '') && (nodeTemplateName !== candidateNodeTemplateName)) {
                puccini.log.debugf('%s: node template %q is not named %q', path, candidateNodeTemplateName, nodeTemplateName);
                continue;
              }

              if ((nodeTypeName !== '') && !(nodeTypeName in candidateNodeTemplate.types)) {
                puccini.log.debugf('%s: node template %q is not of type %q', path, candidateNodeTemplateName, nodeTypeName);
                continue;
              }

              // Node filter
              if ((nodeTemplatePropertyValidators.length !== 0) && !arePropertiesValid(path, sourceVertex, 'node template', candidateNodeTemplateName, candidateNodeTemplate, nodeTemplatePropertyValidators)) {
                puccini.log.debugf('%s: properties of node template %q do not validate', path, candidateNodeTemplateName);
                continue;
              }

              let candidateCapabilities = candidateNodeTemplate.capabilities;

              // Capability filter
              if (capabilityPropertyValidatorsMap.length !== 0) {
                let valid = true;
                for (let candidateCapabilityName in candidateCapabilities) {
                  let candidateCapability = candidateCapabilities[candidateCapabilityName];

                  // Try by name
                  let capabilityPropertyValidators = capabilityPropertyValidatorsMap[candidateCapabilityName];
                  if (capabilityPropertyValidators === undefined) {
                    // Try by type name
                    for (let candidateTypeName in candidateCapability.types) {
                      capabilityPropertyValidators = capabilityPropertyValidatorsMap[candidateTypeName];
                      if (capabilityPropertyValidators !== undefined) break;
                    }
                  }

                  if ((capabilityPropertyValidators !== undefined) && (capabilityPropertyValidators.length !== 0) && !arePropertiesValid(path, sourceVertex, 'capability', candidateCapabilityName, candidateCapability, capabilityPropertyValidators)) {
                    puccini.log.debugf('%s: properties of capability %q in node template %q do not validate', path, candidateCapabilityName, candidateNodeTemplateName);
                    valid = false;
                    break;
                  }
                }
                if (!valid)
                  continue;
              }

              candidates.push({
                vertex: vertex,
                nodeTemplateName: candidateNodeTemplateName,
                capabilities: candidateCapabilities
              });
            }

            return candidates;
          }

          function gatherCandidateCapabilities(requirement, candidateNodeTemplates) {
            let path = requirement.location.path;
            let capabilityName = requirement.capabilityName;
            let capabilityTypeName = requirement.capabilityTypeName;

            let candidates = [];
            for (let c = 0, l = candidateNodeTemplates.length; c < l; c++) {
              let candidate = candidateNodeTemplates[c];
              let candidateVertex = candidate.vertex;
              let candidateNodeTemplateName = candidate.nodeTemplateName;

              let candidateCapabilities = [];
              for (let candidateCapabilityName in candidate.capabilities) {
                candidateCapabilities.push({
                  name: candidateCapabilityName,
                  capability: candidate.capabilities[candidateCapabilityName]
                });
              }

              // For consistent results, we will sort the candidate capabilities by name
              candidateCapabilities.sort(function(a, b) {
                return a.name < b.name ? -1 : 1;
              });

              for (let cc = 0, ll = candidateCapabilities.length; cc < ll; cc++) {
                let candidateCapabilityName = candidateCapabilities[cc].name;

                if ((capabilityName !== '') && (capabilityName !== candidateCapabilityName)) {
                  puccini.log.debugf('%s: capability %q in node template %q is not named %q', path, candidateCapabilityName, candidateNodeTemplateName, capabilityName);
                  continue;
                }

                let candidateCapability = candidateCapabilities[cc].capability;

                if ((capabilityTypeName !== '') && !(capabilityTypeName in candidateCapability.types)) {
                  puccini.log.debugf('%s: capability %q in node template %q is not of type %q', path, candidateCapabilityName, candidateNodeTemplateName, capabilityTypeName);
                  continue;
                }

                if (enforceCapabilityOccurrences) {
                  let maxRelationshipCount = candidateCapability.maxRelationshipCount;
                  if ((maxRelationshipCount !== -1) && (countRelationships(candidateVertex, candidateCapabilityName) === maxRelationshipCount)) {
                    puccini.log.debugf('%s: capability %q in node template %q already has %d relationships, the maximum allowed', path, candidateCapabilityName, candidateNodeTemplateName, maxRelationshipCount);
                    continue;
                  }
                }

                candidates.push({
                  vertex: candidateVertex,
                  nodeTemplateName: candidateNodeTemplateName,
                  capability: candidateCapability,
                  capabilityName: candidateCapabilityName
                });
              }
            }

            return candidates;
          }

          function addRelationship(sourceVertex, requirement, targetVertex, capabilityName) {
            let edge = sourceVertex.newEdgeTo(targetVertex);
            edge.metadata['puccini'] = {
              version: '1.0',
              kind: 'Relationship'
            };

            let relationship = requirement.relationship;
            if (relationship)
              edge.properties = {
                name: requirement.name,
                description: relationship.description,
                types: relationship.types,
                properties: relationship.properties,
                attributes: relationship.attributes,
                interfaces: relationship.interfaces,
                capability: capabilityName
              };
            else
              // Untyped relationship
              edge.properties = {
                name: requirement.name,
                description: '',
                types: {},
                properties: {},
                attributes: {},
                interfaces: {},
                capability: capabilityName
              };
          }

          function countRelationships(vertex, capabilityName) {
            let count = 0;
            for (let e = 0, l = vertex.edgesIn.size(); e < l; e++) {
              let edge = vertex.edgesIn[e];
              if (tosca.isTosca(edge, 'Relationship') && (edge.properties.capability === capabilityName))
                count++;
            }
            return count;
          }

          function arePropertiesValid(path, sourceVertex, kind, name, entity, validatorsMap) {
            let valid = true;

            let properties = entity.properties;
            for (let propertyName in validatorsMap) {
              puccini.log.debugf('%s: applying validators to property %q of %s %q', path, propertyName, kind, name);

              let property = properties[propertyName];
              if (property === undefined) {
                // return false; GOJA: returning from inside for-loop is broken
                valid = false;
                break;
              }

              let validators = validatorsMap[propertyName];
              validators = clout.newValidators(validators, sourceVertex, sourceVertex, entity)
              if (!validators.isValid(property)) {
                // return false; GOJA: returning from inside for-loop is broken
                valid = false;
                break;
              }
            }

            return valid;
          }

          function isSubstituted(nodeTemplateName, requirementName) {
            for (let vertexId in clout.vertexes) {
              let vertex = clout.vertexes[vertexId];
              if (tosca.isTosca(vertex, 'Substitution')) {
                for (let e = 0, l = vertex.edgesOut.size(); e < l; e++) {
                  let edge = vertex.edgesOut[e];
                  if (!tosca.isTosca(edge, 'RequirementPointer'))
                    continue;

                  if ((edge.target.properties.name === nodeTemplateName) && (edge.properties.target === requirementName))
                    return true;
                }

                // There's only ever one substitution
                return false;
              }
            }

            return false;
          }

          function isMaxCountGreater(a, b) {
            if (a == -1)
              return b !== -1;
            else if (b == -1)
              return false;
            return a > b;
          }

          function unsatisfied(location, name, message) {
            if (typeof problems === 'undefined')
              throw puccini.sprintf('%s: could not satisfy %q because %s', location.path, name, message);
            else
              problems.reportFull(11, 'Resolution', location.path, puccini.sprintf('could not satisfy %q because %s', name, message), location.row, location.column);
          }

          function notEnoughRelationships(location, relationshipCount, minRelationshipCount) {
            if (typeof problems === 'undefined')
              throw puccini.sprintf('%s: not enough relationships: %d < %d', location.path, relationshipCount, minRelationshipCount);
            else
              problems.reportFull(11, 'Resolution', location.path, puccini.sprintf('not enough relationships: %d < %d', relationshipCount, minRelationshipCount), location.row, location.column);
          }
    version: "1.0"
properties:
  tosca:
    description: |
      Questo file TOSCA 2.0 definisce tipi personalizzati per un'applicazione semplice (client e server) e un service template che li utilizza, dimostrando una relazione definita tra i nodi. Nota: I tipi personalizzati non derivano da tipi standard in questo esempio.


      Questo template deploya un'istanza del server e un'istanza del client e definisce la loro relazione di connessione.
    inputs: {}
    metadata: {}
    outputs: {}
vertexes:
  _2w8NlkVkOxQdTLyyB2vOAwVaD9B:
    metadata:
      puccini:
        kind: NodeTemplate
        version: "1.0"
    properties:
      artifacts: {}
      attributes: {}
      capabilities:
        app_service:
          attributes: {}
          description: La capability per accedere al servizio offerto dal server.
          location:
            column: 9
            path: service_template.node_templates["my_server_instance"].capabilities["app_service"]
            row: 69
          maxRelationshipCount: -1
          minRelationshipCount: 0
          properties:
            endpoint: 10.0.0.10:5000
          types:
            MyAppServiceCapability:
              description: |
                Una capability che rappresenta un servizio esposto dalla mia applicazione.
      description: Prima istanza del nodo server.
      directives: []
      interfaces: {}
      metadata: null
      name: my_server_instance
      properties:
        server_name: backend-server-prod
      requirements: []
      types:
        MyAppServer:
          description: Tipo di nodo che rappresenta il componente server della mia applicazione.
    edgesOut: []
  _2w8Nlla9pcj1zSjOBFWEzeVa2XB:
    metadata:
      puccini:
        kind: NodeTemplate
        version: "1.0"
    properties:
      artifacts: {}
      attributes: {}
      capabilities: {}
      description: Prima istanza del nodo client.
      directives: []
      interfaces: {}
      metadata: null
      name: my_client_instance
      properties:
        client_name: frontend-client-prod
      requirements:
        - capabilityName: ""
          capabilityPropertyValidators: {}
          capabilityTypeName: MyAppServiceCapability
          directives: null
          location:
            column: 13
            path: service_template.node_templates["my_client_instance"].requirements{0}
            row: 80
          name: server_connection
          nodeTemplateName: my_server_instance
          nodeTemplatePropertyValidators: {}
          nodeTypeName: MyAppServer
          optional: false
          relationship:
            attributes: {}
            description: ""
            interfaces: {}
            metadata: {}
            properties:
              protocol: HTTP
            types:
              ConnectsToMyAppService:
                description: |
                  Una relazione che connette un client a un servizio esposto tramite MyAppServiceCapability.
      types:
        MyAppClient:
          description: Tipo di nodo che rappresenta il componente client della mia applicazione.
    edgesOut:
      - metadata:
          puccini:
            kind: Relationship
            version: "1.0"
        properties:
          attributes: {}
          capability: app_service
          description: ""
          interfaces: {}
          name: server_connection
          properties:
            protocol: HTTP
          types:
            ConnectsToMyAppService:
              description: |
                Una relazione che connette un client a un servizio esposto tramite MyAppServiceCapability.
        targetID: _2w8NlkVkOxQdTLyyB2vOAwVaD9B